<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="webpage: https:&#x2F;&#x2F;cs.nyu.edu&#x2F;~mwalfish&#x2F;classes&#x2F;24sp&#x2F;lab： https:&#x2F;&#x2F;github.com&#x2F;nyu-cs202&#x2F;labs Lecture 1为什么学习OS?我们每天都会跟OS打交道，思考一台电脑是：  disk cpu battery bus &amp; iodevice (popular are monitor &#x2F; keyboa">
<meta property="og:type" content="article">
<meta property="og:title" content="NYU OS log">
<meta property="og:url" content="https://flappy.name/2024/01/22/NYU_OS/index.html">
<meta property="og:site_name" content="VA-11 HALL-B">
<meta property="og:description" content="webpage: https:&#x2F;&#x2F;cs.nyu.edu&#x2F;~mwalfish&#x2F;classes&#x2F;24sp&#x2F;lab： https:&#x2F;&#x2F;github.com&#x2F;nyu-cs202&#x2F;labs Lecture 1为什么学习OS?我们每天都会跟OS打交道，思考一台电脑是：  disk cpu battery bus &amp; iodevice (popular are monitor &#x2F; keyboa">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-1.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-2.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-77.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-80.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-77.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-4.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-9.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-10.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-12.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-13.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-14.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-15.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-16.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-17.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-22.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-30.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-5.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-23.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-26.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-27.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-29.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-31.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-32.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-33.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-34.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-35.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-36.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-37.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-49.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-48.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-51.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-50.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-52.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-53.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-54.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-55.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-56.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-57.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-58.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-19.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-20.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-59.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-42.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-43.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-44.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-45.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-46.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-61.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-62.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-60.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-63.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-64.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-47.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-67.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-66.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-65.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-68.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-69.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-70.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-71.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-72.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-75.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-76.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-7.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-8.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-11.png">
<meta property="og:image" content="https://flappy.name/2024/01/22/NYU_OS/image-18.png">
<meta property="article:published_time" content="2024-01-22T07:10:11.000Z">
<meta property="article:modified_time" content="2025-01-29T19:34:57.517Z">
<meta property="article:author" content="Shengtao Yao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://flappy.name/2024/01/22/NYU_OS/image-1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-96x96.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>NYU OS log</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="VA-11 HALL-B" type="application/atom+xml" />
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/links/">Links</a></li><!--
     --><!--
       --><li><a href="/academic">Academic Page</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/09/nyu-second_half_sp/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/12/23/Minds-and-Machines/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://flappy.name/2024/01/22/NYU_OS/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://flappy.name/2024/01/22/NYU_OS/&text=NYU OS log"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://flappy.name/2024/01/22/NYU_OS/&is_video=false&description=NYU OS log"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=NYU OS log&body=Check out this article: https://flappy.name/2024/01/22/NYU_OS/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://flappy.name/2024/01/22/NYU_OS/&name=NYU OS log&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://flappy.name/2024/01/22/NYU_OS/&t=NYU OS log"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-1"><span class="toc-number">1.</span> <span class="toc-text">Lecture 1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0OS"><span class="toc-number">1.1.</span> <span class="toc-text">为什么学习OS?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-2-3-Review-of-assembly"><span class="toc-number">2.</span> <span class="toc-text">Lecture 2&#x2F;3 Review of assembly</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x86-64-assembly"><span class="toc-number">2.1.</span> <span class="toc-text">x86-64 assembly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#design-of-assembly"><span class="toc-number">2.2.</span> <span class="toc-text">design of assembly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#syscall"><span class="toc-number">2.3.</span> <span class="toc-text">syscall</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-4-Shell-I"><span class="toc-number">3.</span> <span class="toc-text">Lecture 4: Shell I</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">3.1.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execve"><span class="toc-number">3.2.</span> <span class="toc-text">execve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-%E2%80%93-%E4%BB%8EOS%E7%9A%84%E8%A7%92%E5%BA%A6"><span class="toc-number">3.3.</span> <span class="toc-text">Process – 从OS的角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-%E2%80%93-%E4%BB%8EOS%E7%9A%84%E8%A7%92%E5%BA%A6"><span class="toc-number">3.4.</span> <span class="toc-text">thread – 从OS的角度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-1-2"><span class="toc-number">4.</span> <span class="toc-text">HW 1&#x2F;2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-Lab2-ls"><span class="toc-number">5.</span> <span class="toc-text">Lab1&#x2F; Lab2 ls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Argument-parsing"><span class="toc-number">5.1.</span> <span class="toc-text">Argument parsing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-Directories-file-systems-api"><span class="toc-number">5.2.</span> <span class="toc-text">Read Directories&#x2F; file systems api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation"><span class="toc-number">5.3.</span> <span class="toc-text">Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Testing-framework"><span class="toc-number">5.3.1.</span> <span class="toc-text">Testing framework</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-5-6-7-8-Concurrency-I-II-III-IV"><span class="toc-number">6.</span> <span class="toc-text">Lecture 5&#x2F;6&#x2F;7&#x2F;8: Concurrency I&#x2F;II&#x2F;III&#x2F;IV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8E%AA%E6%96%BD%EF%BC%9Alock"><span class="toc-number">6.1.</span> <span class="toc-text">第一个措施：lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%8E%AA%E6%96%BD%EF%BC%9Acv"><span class="toc-number">6.2.</span> <span class="toc-text">第二个措施：cv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combined-primitive-monitor"><span class="toc-number">6.3.</span> <span class="toc-text">Combined primitive: monitor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%83%E4%B9%A0%E3%80%82"><span class="toc-number">6.4.</span> <span class="toc-text">一些练习。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-of-lock"><span class="toc-number">6.5.</span> <span class="toc-text">Implementation of lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spin-lock"><span class="toc-number">6.6.</span> <span class="toc-text">spin lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spinlock-%E2%80%93-Lecture-stuff"><span class="toc-number">6.7.</span> <span class="toc-text">spinlock – Lecture stuff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spinlock-based-mutex"><span class="toc-number">6.8.</span> <span class="toc-text">Spinlock-based mutex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-3-4-5"><span class="toc-number">7.</span> <span class="toc-text">HW 3&#x2F;4&#x2F;5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-The-uses-of-threading"><span class="toc-number">7.1.</span> <span class="toc-text">1. The uses of threading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-practice"><span class="toc-number">7.2.</span> <span class="toc-text">2. practice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Time-of-check-to-time-of-use-TOCTTOU-bugs"><span class="toc-number">7.3.</span> <span class="toc-text">3. Time-of-check-to-time-of-use (TOCTTOU) bugs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Deadlock"><span class="toc-number">7.4.</span> <span class="toc-text">4. Deadlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Priority-Inversion"><span class="toc-number">7.5.</span> <span class="toc-text">5. Priority Inversion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Reader-Writer-Spinlock-Challenge"><span class="toc-number">7.6.</span> <span class="toc-text">6. Reader Writer Spinlock (Challenge)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84c-bug"><span class="toc-number">7.7.</span> <span class="toc-text">一个典型的c bug</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-9-Therac-25"><span class="toc-number">8.</span> <span class="toc-text">Lecture 9 Therac 25</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-10-Scheduler"><span class="toc-number">9.</span> <span class="toc-text">Lecture 10 Scheduler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-11-12-13-15-Virtual-Memory-I-II-III-IV"><span class="toc-number">10.</span> <span class="toc-text">Lecture 11&#x2F;12&#x2F;13&#x2F;15 Virtual Memory I&#x2F;II&#x2F;III&#x2F;IV&#x2F;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84-kernel%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">页表是怎么工作的 &lt;&#x3D;&#x3D;&gt; kernel中的代码逻辑是什么样的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hw-6-7-8"><span class="toc-number">11.</span> <span class="toc-text">hw 6&#x2F;7&#x2F;8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-16-I-O-in-general"><span class="toc-number">12.</span> <span class="toc-text">Lecture 16 I&#x2F;O in general</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-17-Context-Switch"><span class="toc-number">13.</span> <span class="toc-text">Lecture 17: Context Switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-18-Disks"><span class="toc-number">14.</span> <span class="toc-text">Lecture 18: Disks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Performance-%E8%AE%A1%E7%AE%97%EF%BC%9A"><span class="toc-number">14.1.</span> <span class="toc-text">Performance 计算：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hw9"><span class="toc-number">15.</span> <span class="toc-text">hw9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-mmap"><span class="toc-number">15.1.</span> <span class="toc-text">1. mmap()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Context-switches"><span class="toc-number">15.2.</span> <span class="toc-text">2. Context switches</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Polling-vs-interrupts"><span class="toc-number">15.3.</span> <span class="toc-text">3. Polling vs. interrupts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Disk-performance"><span class="toc-number">15.4.</span> <span class="toc-text">4. Disk performance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Disk-scheduling"><span class="toc-number">15.5.</span> <span class="toc-text">5. Disk scheduling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-19-20-File-systems-I-II"><span class="toc-number">16.</span> <span class="toc-text">Lecture 19&#x2F;20: File systems I&#x2F;II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file-system%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">16.1.</span> <span class="toc-text">file system的功能:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Files-Implementations"><span class="toc-number">16.2.</span> <span class="toc-text">Files Implementations:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-of-Directories"><span class="toc-number">16.3.</span> <span class="toc-text">Implementation of Directories</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-10-FS"><span class="toc-number">17.</span> <span class="toc-text">HW 10 FS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-File-systems"><span class="toc-number">17.1.</span> <span class="toc-text">1. File systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-File-systems"><span class="toc-number">17.2.</span> <span class="toc-text">2. File systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Zero-copy-I-O"><span class="toc-number">17.3.</span> <span class="toc-text">3. Zero-copy I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-21-Crash-recovery"><span class="toc-number">18.</span> <span class="toc-text">Lecture 21: Crash recovery</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-copy-on-write"><span class="toc-number">18.1.</span> <span class="toc-text">2. copy on write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Journaling"><span class="toc-number">18.2.</span> <span class="toc-text">3. Journaling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-logging"><span class="toc-number">18.2.1.</span> <span class="toc-text">redo logging:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-logging"><span class="toc-number">18.2.2.</span> <span class="toc-text">undo logging:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-11-File-systems-reliability"><span class="toc-number">19.</span> <span class="toc-text">HW 11: File systems reliability</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-File-systems-1"><span class="toc-number">19.1.</span> <span class="toc-text">1. File systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-File-systems-1"><span class="toc-number">19.2.</span> <span class="toc-text">2. File systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Crash-recovery-Copy-on-write"><span class="toc-number">19.3.</span> <span class="toc-text">3. Crash recovery: Copy-on-write</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Crash-recovery-Undo-redo-logging"><span class="toc-number">19.3.1.</span> <span class="toc-text">4. Crash recovery: Undo-redo logging</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-22-NFS"><span class="toc-number">20.</span> <span class="toc-text">Lecture 22: NFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-23-stack-smashing"><span class="toc-number">21.</span> <span class="toc-text">Lecture 23: stack smashing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-24-Reflection-on-trusting-trust"><span class="toc-number">22.</span> <span class="toc-text">Lecture 24: Reflection on trusting trust</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-25-UNIX"><span class="toc-number">23.</span> <span class="toc-text">Lecture 25 UNIX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8Dattack%EF%BC%9A%E5%B0%8F%E5%81%B7%E5%B0%8F%E6%91%B8-%E4%B9%8B-lunch-break-attack"><span class="toc-number">23.1.</span> <span class="toc-text">第一种attack：小偷小摸 之 lunch break attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%A7%8Dattack%EF%BC%9Afd-table-attack"><span class="toc-number">23.2.</span> <span class="toc-text">例子：第二种attack：fd table attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%A7%8Dattack%EF%BC%9A%E5%A5%87%E8%91%A9preserve%E7%A8%8B%E5%BA%8F"><span class="toc-number">23.3.</span> <span class="toc-text">例子：第三种attack：奇葩preserve程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TOCTTOU-attacks-time-of-check-to-time-of-use"><span class="toc-number">23.4.</span> <span class="toc-text">TOCTTOU attacks (time-of-check-to-time-of-use)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-12-NFS-security-and-review"><span class="toc-number">24.</span> <span class="toc-text">HW 12 NFS, security and review</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Crash-recovery"><span class="toc-number">24.1.</span> <span class="toc-text">1. Crash recovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Buffer-overflow-vulnerabilities"><span class="toc-number">24.2.</span> <span class="toc-text">2. Buffer overflow vulnerabilities</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab-5-File-system"><span class="toc-number">25.</span> <span class="toc-text">Lab 5: File system</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">25.1.</span> <span class="toc-text">前置知识：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercise"><span class="toc-number">25.2.</span> <span class="toc-text">Exercise</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        NYU OS log
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Shengtao Yao</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-01-22T07:10:11.000Z" class="dt-published" itemprop="datePublished">2024-01-22</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/learn/">learn</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>webpage: <a target="_blank" rel="noopener" href="https://cs.nyu.edu/~mwalfish/classes/24sp/">https://cs.nyu.edu/~mwalfish/classes/24sp/</a><br>lab： <a target="_blank" rel="noopener" href="https://github.com/nyu-cs202/labs">https://github.com/nyu-cs202/labs</a></p>
<h2 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h2><h3 id="为什么学习OS"><a href="#为什么学习OS" class="headerlink" title="为什么学习OS?"></a>为什么学习OS?</h3><p>我们每天都会跟OS打交道，思考一台电脑是：</p>
<ul>
<li>disk</li>
<li>cpu</li>
<li>battery</li>
<li>bus &amp; iodevice (popular are monitor &#x2F; keyboard &#x2F; touchbar &#x2F; mouse)</li>
<li>。。。</li>
</ul>
<p>的集合。OS做的就是把这一坨，硬不拉几的东西做的可以和人类沟通。</p>
<ul>
<li>比如让东西显示在显示器上。</li>
</ul>
<p>如果你想解密，那么我认为OS是一门非常好的system探险课。</p>
<ol>
<li><p>“我们现在都要work with AI的，为什么要学os?” 正是AI engineer需要和硬件交朋友。首先require大算力的应用只会越来越被需要，这个时候学会和真正的物理资源打交道是很有必要的，这种只会被无限的需求，因为在抽象层是充满了很多细节要被优化的。最要被替代的是那些只会照猫画虎调参的。这是从实用角度为什么要学os&#x2F;sys的原因。<strong>算力本身是电力，学会如何和算力打交道是大势所趋</strong>，因为他相当基础且需求大，它很少会被替代。</p>
</li>
<li><p>Hardware是ugly的，从软件工程师的角度。如果没有好的design，那么deal with hardware everyday无疑是一个劳动密集的工作。正是因为有这层抽象，让写码本身变得优雅了很多。这是从美学的角度的一个为什么学os的原因。它<strong>简单，强大，优雅。</strong></p>
</li>
<li><p>OS demonstrate了不少软件工程中重要的概念。比如scheduler是经典的调度问题&#x2F; 在和processes打交道的时候会接触到并行。</p>
</li>
</ol>
<h2 id="Lecture-2-3-Review-of-assembly"><a href="#Lecture-2-3-Review-of-assembly" class="headerlink" title="Lecture 2&#x2F;3 Review of assembly"></a>Lecture 2&#x2F;3 Review of assembly</h2><img src="/2024/01/22/NYU_OS/image-1.png" class="" title="Alt text">

<p>Process is key of abstraction of OS </p>
<ol>
<li>Process is the machine code running on computers. </li>
<li>OS as resource manager will manage processes as resources.</li>
</ol>
<p>What does a process construct of?</p>
<img src="/2024/01/22/NYU_OS/image-2.png" class="" title="Alt text">

<img src="/2024/01/22/NYU_OS/image-77.png" class="" title="alt text">
<p>How a process is loaded? </p>
<h3 id="x86-64-assembly"><a href="#x86-64-assembly" class="headerlink" title="x86-64 assembly"></a>x86-64 assembly</h3><p><a target="_blank" rel="noopener" href="https://cs61.seas.harvard.edu/site/2024/Asm/#gsc.tab=0">https://cs61.seas.harvard.edu/site/2024/Asm/#gsc.tab=0</a></p>
<p>Review stack:<br><a target="_blank" rel="noopener" href="https://cs.nyu.edu/~qc1127/classes/24fa/lectures/handout03.pdf">https://cs.nyu.edu/~qc1127/classes/24fa/lectures/handout03.pdf</a></p>
<h3 id="design-of-assembly"><a href="#design-of-assembly" class="headerlink" title="design of assembly"></a>design of assembly</h3><p>重新想了一下，Caller和Callee的设计很精妙。相当于用了一层人类的简单的规约去释放了很多设计空间，因为正常的temporary variable不可能不用，不可能全用stack的空间；但是又不能全部都搞成temporary variable，这样要saved variable太几把多了。所以干脆搞一个规约，让一半去负责特定的东西，frame ptr，stack ptr这种，而且callee得负责回去的时候全部的值都不变，让另外一半register让callee随便用，但是回到caller的时候让caller自己搞定。</p>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><img src="/2024/01/22/NYU_OS/image-80.png" class="" title="alt text">
<img src="/2024/01/22/NYU_OS/image-77.png" class="" title="alt text">

<h2 id="Lecture-4-Shell-I"><a href="#Lecture-4-Shell-I" class="headerlink" title="Lecture 4: Shell I"></a>Lecture 4: Shell I</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><blockquote>
<p>execve() executes the program referred to by pathname. This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and uninitialized) data segments</p>
</blockquote>
<p>execve(“&#x2F;bin&#x2F;sh”,0,0)是个系统调用，执行后，即使他发生在某个线程中，整个进程的程序也会被换掉，但进程号保留。</p>
<p>我们先来看一个简单的shell模型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;$&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    readcmd(cmd, args);</span><br><span class="line">    <span class="comment">// child</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        execve(command, args, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原料：fork execve.</p>
<p>实现：让一个parent process来manage i&#x2F;o，然后创造子进程来跑用户想跑的程序。</p>
<p>目的：为了脱离原始的batch computing，让用户有操作多个任务的能力。</p>
<p><strong>fs</strong> – file descriptor:  </p>
<img src="/2024/01/22/NYU_OS/image-4.png" class="" title="alt text">

<p>接下来我们来看redirection和后台运行的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;$&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    readcmd(cmd, args);</span><br><span class="line">    <span class="comment">// child</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (redirected) &#123;</span><br><span class="line">            close(<span class="number">1</span>);</span><br><span class="line">            open(redirected_file);</span><br><span class="line">        &#125;</span><br><span class="line">        execve(command, args, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fore_ground) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Redirection</strong>: 它的实现踩在了file descriptor的肩膀上。只不过就是把fs的1的指针从指向terminal到指向了新的file。注意write这个syscall完全不知道发生了什么，他一样写入了fs为1的地方，只不过这次是用户指定的file而不是terminal。</p>
<p><strong>background</strong>：它的实现是 — 如果shell parse到了&amp;，parent processes直接不等了，直接让execve在后台运行。</p>
<p>Question:</p>
<ul>
<li>为什么fork和exec要隔离开来?为什么不直接有一个craeteprocess？难道这样不更方便？</li>
</ul>
<p><strong>ans</strong>: 其实这样给了用户更多的操作空间，一个用来创造新process，然后用户可以在fork中的函数中疯狂配环境，就像redirection是怎么实现的一样。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 奇怪的脚本，赶紧试试吧！</span></span><br><span class="line">$ :()&#123;:1:&amp;&#125;;:</span><br></pre></td></tr></table></figure>

<p><strong>pipeline</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;$&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    readcmd(cmd, args);</span><br><span class="line">    <span class="comment">// child</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (redirected) &#123;</span><br><span class="line">            close(<span class="number">1</span>);</span><br><span class="line">            open(redirected_file);</span><br><span class="line">        &#125;</span><br><span class="line">        execve(command, args, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fore_ground) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> handle_piepeline(left_cmd, right_cmd) &#123;</span><br><span class="line">    <span class="type">int</span> fdArr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(fdArr) &lt; <span class="number">0</span>) <span class="comment">//error</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        dup2(fdArr[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// now fd 0 -&gt; dev, 1 -&gt; write end, 2 -&gt; dev</span></span><br><span class="line">        close(fdArr[<span class="number">0</span>]);</span><br><span class="line">        close(fdArr[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// execute.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dup2(fdArr[<span class="number">0</span>], <span class="number">0</span>); <span class="comment">// now fd 0 -&gt; dev, 1 -&gt; write end, 2 -&gt; dev</span></span><br><span class="line">        close(fdArr[<span class="number">0</span>]);</span><br><span class="line">        close(fdArr[<span class="number">1</span>]);</span><br><span class="line">     <span class="comment">// error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<ul>
<li>left cmd &#x3D; <code>ls -l</code>的输出原本是1，which is defaulted set to the terminal windo.</li>
<li>right cmd &#x3D; <code>grep &#39;pattern&#39;</code>，grep在没有第三个arg的实现是用fd 0 作为自己的input，如果有第三个arg输进去，那他就会吧0 关闭，然后在调用open syscall。</li>
</ul>
<p>然鹅我们再shell的实现中 – 直接关闭ls -l side的1， 然后打开grep side的0，就可以实现pipe了。于是<code>ls -l | grep &quot;hello&quot;</code> 就会从ls -l 输入到管道中，然后grep再从fd&#x3D;0读取（管道的输出）内容。</p>
<p>我们来深入理解一下pipe的机制，以下是ls lab的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">hack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="comment">// pipe from child to parent</span></span><br><span class="line">    <span class="type">int</span> c2p[<span class="number">2</span>];</span><br><span class="line">    pipe(c2p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c2p[0] = %d\n&quot;</span>, c2p[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c2p[1] = %d\n&quot;</span>, c2p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// child</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// so instead of writing to terminal, it will write to the pipe.</span></span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// let write end be assiged to fd=1</span></span><br><span class="line">        dup(c2p[WRITEEND]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// close these two ends since we only needs the fd=1(write end) as the output.</span></span><br><span class="line">        close(c2p[READEND]);</span><br><span class="line">        close(c2p[WRITEEND]);</span><br><span class="line">        <span class="type">char</span> *lala[] = &#123;<span class="string">&quot;/usr/bin/ls&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        execve(<span class="string">&quot;/usr/bin/ls&quot;</span>, lala, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parent</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// close it since we dont need it in parent process</span></span><br><span class="line">        close(c2p[WRITEEND]);</span><br><span class="line">        <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">        <span class="type">int</span> n = read(c2p[READEND], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            write(<span class="number">1</span>, buf, n);</span><br><span class="line">            n = read(c2p[READEND], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Process-–-从OS的角度"><a href="#Process-–-从OS的角度" class="headerlink" title="Process – 从OS的角度"></a>Process – 从OS的角度</h3><p>Proc就是一个一堆Proc表，每次booting的时候都用表里的信息来load进去，表如下，可以看看xv6的代码。</p>
<img src="/2024/01/22/NYU_OS/image-9.png" class="" title="Alt text">

<h3 id="thread-–-从OS的角度"><a href="#thread-–-从OS的角度" class="headerlink" title="thread – 从OS的角度"></a>thread – 从OS的角度</h3><p>Thread从proc的角度来看，其实和proc差不多。</p>
<img src="/2024/01/22/NYU_OS/image-10.png" class="" title="Alt text">

<p>每个thread都会维护自己的registers和stack space，甚至在process的视角里，每个thread的不同只不过是它们的registers罢了。但是他们指向的.text and .data area都是一样的（也就是，他们share的code，和global variable是一样的）。这样程序员会觉得觉得他们在“同时”执行一些操作。</p>
<img src="/2024/01/22/NYU_OS/image-12.png" class="" title="Alt text">

<p><strong>线程写的问题</strong>。当x是一个global的时候，两个线程同时都可以access到一个地方，所以会造成线程写的问题。</p>
<img src="/2024/01/22/NYU_OS/image-13.png" class="" title="Alt text">

<h2 id="HW-1-2"><a href="#HW-1-2" class="headerlink" title="HW 1&#x2F;2"></a>HW 1&#x2F;2</h2><ul>
<li>Operations on files, such as read(), write(), and close(), are typically implemented as system calls. Describe two of the benefits of having these operations managed by the operating system instead of individual processes.</li>
</ul>
<p><strong>ans</strong>:<br>(1) Prevent user level processes from manipulating hardware<br>(2) Program will have good portability across machines<br>(3) Processes do not have to have redundant code</p>
<ul>
<li>What do you think are the differences between the implementation of thread_create(func) and the implementation of fork()? (here, func is the address of the function that the thread should begin at).</li>
</ul>
<p><strong>ans</strong>:</p>
<p>D1: thread_create doesn’t need to make a copy of the invoking thread’s memory. It will make both the original thread and created thread share the invoking thread’s memory. By contrast, fork will make a copy of the parent process’s memory, and the child will run using this copy.</p>
<p>D2: Both thread_create and fork will give the created thread&#x2F;process a new stack. fork creates this stack from the parent process’s stack, while thread_create creates a brand new stack. In other words, fork will set %esp to a copy of the current bottom of the stack, thread_create will set %esp to the top of a new stack within the same address space.</p>
<p>D3: As indicated in the interface, thread_create takes a function pointer as the parameter. thread_create will set the created thread’s %eip to func, while fork will not touch %eip, since parent and child are running the “same” code located at the “same” address.</p>
<h2 id="Lab1-Lab2-ls"><a href="#Lab1-Lab2-ls" class="headerlink" title="Lab1&#x2F; Lab2 ls"></a>Lab1&#x2F; Lab2 ls</h2><p><strong>Unix Utilities</strong>.</p>
<ul>
<li>basic shell command</li>
</ul>
<ul>
<li>echo “echo hello $world”? $world will expand</li>
<li>echo ‘echo hello $world’ world will not expand in single quote.</li>
<li>echo `echo hello $world`? what is inside `` will be evaluted first.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> a &amp;&amp; <span class="built_in">echo</span> b <span class="comment"># it cares whether echo a execuets successfully</span></span><br><span class="line"><span class="built_in">echo</span> a ; <span class="built_in">echo</span> b <span class="comment"># it does not care whether echo a execuets successfully]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Explanation: &amp; will put &#x27;echo a&#x27; in background and run &#x27;echo b&#x27; in foreground.</span></span><br><span class="line"><span class="built_in">echo</span> a &amp; <span class="built_in">echo</span> b</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>find</strong>: <code>find [flags] [path...] [expression]; </code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;sched.h&quot;</span></span><br><span class="line">find . -name <span class="string">&quot;sched.*&quot;</span></span><br><span class="line">find . -name <span class="string">&quot;*.h&quot;</span> | <span class="built_in">wc</span> -w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些组合 output</span></span><br><span class="line"><span class="built_in">cat</span> member.txt | grep <span class="string">&quot;^Name:[a-zA-Z&#x27;]\+$&quot;</span> |  <span class="built_in">head</span> -n100 | <span class="built_in">cut</span> -d<span class="string">&#x27;:&#x27;</span> -f 2 | <span class="built_in">sort</span> &gt; name.txt</span><br></pre></td></tr></table></figure>

<p>Personal Note for lab2</p>
<p>What I learnt:</p>
<ul>
<li><p><strong>磨刀不误砍柴工</strong>。在我们既有的抽象层细细的去了解自己的工具。在 lab2 我们的工作是 base on system calls -&gt; implement user functions. So understanding those tools deeply has value in it.</p>
</li>
<li><p>学习一个api最好的方式就是玩它. And That’s it and even more sophisticated syscall needs testing. Learning by playing is the most interesting and the most valuable when learning some apis.</p>
</li>
<li><p><strong>心态上不要恐惧</strong>。很多时候依附于某种语言的特性都会有一些 trick 让原本的代码变得难读。不要着急，一步一步调试后你就能理解其中的优美之处。所以，多多阅读优秀的源码并且理解是可以比读书收获很多的。</p>
</li>
</ul>
<h3 id="Argument-parsing"><a href="#Argument-parsing" class="headerlink" title="Argument parsing"></a>Argument parsing</h3><p>本质上get_opt 和getopt_long差不多。<br>getopt_long();</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> digit_optind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start parsins flags</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// set optind to 1 if it is not set</span></span><br><span class="line">        <span class="type">int</span> this_option_optind = optind ? optind : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> option_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this struct maps long options into int 0.</span></span><br><span class="line">        <span class="comment">// first is long option name</span></span><br><span class="line">        <span class="comment">// second is argument requirement?</span></span><br><span class="line">        <span class="comment">// third is flag</span></span><br><span class="line">        <span class="comment">// fourht is the short option it maps to.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * struct option &#123;</span></span><br><span class="line"><span class="comment">         *   const char *name;</span></span><br><span class="line"><span class="comment">         *   has_arg can&#x27;t be an enum because some compilers complain about</span></span><br><span class="line"><span class="comment">         *   type mismatches in all the code that assumes it is an int.</span></span><br><span class="line"><span class="comment">         *   int has_arg;</span></span><br><span class="line"><span class="comment">         *   int *flag;</span></span><br><span class="line"><span class="comment">         *   int val;</span></span><br><span class="line"><span class="comment">         *   &#125;;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] =</span> &#123;</span><br><span class="line">            &#123;<span class="string">&quot;add&quot;</span>, required_argument, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;append&quot;</span>, no_argument, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;delete&quot;</span>, required_argument, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;verbose&quot;</span>, no_argument, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;create&quot;</span>, required_argument, <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;file&quot;</span>, required_argument, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the flag option, it turns long options into short option through struct option mapping</span></span><br><span class="line">        c = getopt_long(argc, argv, <span class="string">&quot;abc:d:012&quot;</span>,</span><br><span class="line">                        long_options, &amp;option_index);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">// option_index is used to indexing the option struct .</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;option %s&quot;</span>, long_options[option_index].name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在跑过之后，如果有会生成一个optarg, 如果读成功 -- 返回那个string</span></span><br><span class="line">            <span class="keyword">if</span> (optarg)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; with arg %s&quot;</span>, optarg);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Short options</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (digit_optind != <span class="number">0</span> &amp;&amp; digit_optind != this_option_optind)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;digits occur in two different argv-elements.\n&quot;</span>);</span><br><span class="line">            digit_optind = this_option_optind;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;option %c\n&quot;</span>, c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;option a\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;option b\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;option c with value &#x27;%s&#x27;\n&quot;</span>, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;option d with value &#x27;%s&#x27;\n&quot;</span>, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;?? getopt returned character code 0%o ??\n&quot;</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optind should be checked since remember</span></span><br><span class="line">    <span class="comment">// c does not have limit check but it is leaves to you</span></span><br><span class="line">    <span class="comment">// we needs to ensures that optind is not pointing to other memory.</span></span><br><span class="line">    <span class="keyword">if</span> (optind &lt; argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;optind -&gt; %d\n&quot;</span>, optind);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argc -&gt; %d\n&quot;</span>, argc);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;non-option ARGV-elements: &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (optind &lt; argc)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, argv[optind++]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一些例子。</span></span><br><span class="line">cs202-user@ac03bcbbed6b:~/cs202-labs/test$ ./exec --create 1</span><br><span class="line">option c with value <span class="string">&#x27;1&#x27;</span></span><br><span class="line">cs202-user@ac03bcbbed6b:~/cs202-labs/test$ ./exec --c 1</span><br><span class="line">option c with value <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">cs202-user@ac03bcbbed6b:~/cs202-labs/test$ ./exec -ab -c 123 123</span><br><span class="line">option a</span><br><span class="line">option b</span><br><span class="line">option c with value <span class="string">&#x27;123&#x27;</span></span><br><span class="line">non-option ARGV-elements: <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Read-Directories-file-systems-api"><a href="#Read-Directories-file-systems-api" class="headerlink" title="Read Directories&#x2F; file systems api"></a>Read Directories&#x2F; file systems api</h3><p>Dir Stream 其实就是 an ordered sequence of all the directory entries in a particular directory，跟打开一个 fd 的感觉一样，都是抽象成一个流。从用户层面理解没有什么意义，会调用能跑就行了。</p>
<ul>
<li><strong>opendir</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="comment">// open dir stream.</span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// Filename entries can be read from a directory stream using readdir(3).</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>dirp 是一个指针指向了这个流。（This stream can be specified as a linear sequence of struct directory）。</p>
</li>
<li><p>用readdir返回struct dirent</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* Type of file; not supported</span></span><br><span class="line"><span class="comment">                                    by all filesystem types */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="keyword">struct</span> dirent *dp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d_ino -&gt; %ld\n&quot;</span>, dp-&gt;d_ino);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d_off -&gt; %ld\n&quot;</span>, dp-&gt;d_off);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d_reclen -&gt; %d\n&quot;</span>, dp-&gt;d_reclen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d_type -&gt; %d\n&quot;</span>, dp-&gt;d_type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d_name -&gt; %s\n&quot;</span>, dp-&gt;d_name);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dirp = opendir(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span>;</span></span><br><span class="line">    <span class="type">int</span> errno;</span><br><span class="line">    <span class="comment">// Read as null it reaches end</span></span><br><span class="line">    <span class="keyword">while</span> ((dp = readdir(dirp)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        display(dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We&#x27;ve finished reading! \n&quot;</span>);</span><br><span class="line">    closedir(dirp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出是下面：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">d_ino -&gt; 39986</span><br><span class="line">d_off -&gt; 2122451233231811000</span><br><span class="line">d_reclen -&gt; 32</span><br><span class="line">d_type -&gt; 8</span><br><span class="line">d_name -&gt; main.c</span><br><span class="line"></span><br><span class="line">d_ino -&gt; 29864</span><br><span class="line">d_off -&gt; 6629703606815583833</span><br><span class="line">d_reclen -&gt; 24</span><br><span class="line">d_type -&gt; 4</span><br><span class="line">d_name -&gt; ..</span><br><span class="line"></span><br><span class="line">d_ino -&gt; 31553</span><br><span class="line">d_off -&gt; 7336315452623241479</span><br><span class="line">d_reclen -&gt; 24</span><br><span class="line">d_type -&gt; 8</span><br><span class="line">d_name -&gt; <span class="built_in">exec</span></span><br><span class="line"></span><br><span class="line">d_ino -&gt; 39987</span><br><span class="line">d_off -&gt; 8301092125137062404</span><br><span class="line">d_reclen -&gt; 24</span><br><span class="line">d_type -&gt; 4</span><br><span class="line">d_name -&gt; .</span><br><span class="line"></span><br><span class="line">d_ino -&gt; 39988</span><br><span class="line">d_off -&gt; 9223372036854775807</span><br><span class="line">d_reclen -&gt; 32</span><br><span class="line">d_type -&gt; 8</span><br><span class="line">d_name -&gt; test.sh</span><br><span class="line"></span><br><span class="line">We<span class="string">&#x27;ve finished reading!</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lookup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dirp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dirp = opendir(<span class="string">&quot;.&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;couldn&#x27;t open &#x27;.&#x27;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// set errno to 0 to enforce checking error</span></span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((dp = readdir(dirp)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dp-&gt;d_name, arg) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            (<span class="type">void</span>) <span class="built_in">printf</span>(<span class="string">&quot;found %s\n&quot;</span>, arg);</span><br><span class="line">            (<span class="type">void</span>) closedir(dirp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// end if dp is NULL</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (dp != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;error reading directory&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        (<span class="type">void</span>) <span class="built_in">printf</span>(<span class="string">&quot;failed to find %s\n&quot;</span>, arg);</span><br><span class="line">    (<span class="type">void</span>) closedir(dirp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        lookup(argv[i]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>stat 调用</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;pathname&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lstat(argv[<span class="number">1</span>], &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;lstat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID of containing device:  [%jx,%jx]\n&quot;</span>,</span><br><span class="line">           (<span class="type">uintmax_t</span>)major(sb.st_dev),</span><br><span class="line">           (<span class="type">uintmax_t</span>)minor(sb.st_dev));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File type:                &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (sb.st_mode &amp; S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;character device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;directory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO/pipe\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;symlink\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFREG:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown?\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I-node number:            %ju\n&quot;</span>, (<span class="type">uintmax_t</span>)sb.st_ino);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mode:                     %jo (octal)\n&quot;</span>,</span><br><span class="line">           (<span class="type">uintmax_t</span>)sb.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Link count:               %ju\n&quot;</span>, (<span class="type">uintmax_t</span>)sb.st_nlink);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ownership:                UID=%ju   GID=%ju\n&quot;</span>,</span><br><span class="line">           (<span class="type">uintmax_t</span>)sb.st_uid, (<span class="type">uintmax_t</span>)sb.st_gid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Preferred I/O block size: %jd bytes\n&quot;</span>,</span><br><span class="line">           (<span class="type">intmax_t</span>)sb.st_blksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File size:                %jd bytes\n&quot;</span>,</span><br><span class="line">           (<span class="type">intmax_t</span>)sb.st_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Blocks allocated:         %jd\n&quot;</span>,</span><br><span class="line">           (<span class="type">intmax_t</span>)sb.st_blocks);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last status change:       %s&quot;</span>, ctime(&amp;sb.st_ctime));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last file access:         %s&quot;</span>, ctime(&amp;sb.st_atime));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last file modification:   %s&quot;</span>, ctime(&amp;sb.st_mtime));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ID of containing device:  [8,20]</span><br><span class="line">File <span class="built_in">type</span>:                directory</span><br><span class="line">I-node number:            39987</span><br><span class="line">Mode:                     40755 (octal)</span><br><span class="line">Link count:               2</span><br><span class="line">Ownership:                UID=1000   GID=1000</span><br><span class="line">Preferred I/O block size: 4096 bytes</span><br><span class="line">File size:                4096 bytes</span><br><span class="line">Blocks allocated:         8</span><br><span class="line">Last status change:       Sat Feb  3 01:36:49 2024</span><br><span class="line">Last file access:         Sat Feb  3 01:36:53 2024</span><br><span class="line">Last file modification:   Sat Feb  3 01:36:49 2024</span><br></pre></td></tr></table></figure>

<p><strong>inode</strong><br>Each file has an inode containing metadata about the file. An application can retrieve this metadata using stat(2) (or related calls), which returns a stat structure, or statx(2), which returns a statx structure.</p>
<p>在 manual 里写的最重要的无非是 – <code>stat</code>中返回的 struct 中<code>st.mode</code>是 type, filemode 的 bitmask。我们可以通过一些 manual 中提供的 marco 去轻易获得。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S_IFMT     0170000   bit mask for the file type bit field</span></span><br><span class="line"> stat(pathname, &amp;sb);</span><br><span class="line"><span class="keyword">if</span> ((sb.st_mode &amp; S_IFMT) == S_IFREG) &#123;</span><br><span class="line">    <span class="comment">/* Handle regular file */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if we want to check S_IRWXU     00700   if owner has read, write, and execute permission</span></span><br><span class="line"><span class="keyword">if</span> ((sb.st_mode &amp; S_IFMT) == S_IFREG) &#123;</span><br><span class="line">    <span class="comment">/* Handle  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p><em>2024&#x2F;02&#x2F;03</em><br>写了不少了，但是还是有很多常识的错误。<br>BUG：</p>
<ul>
<li><p>implement目录的时候，想当然的把自己当成用户了（以为系统会自己帮我把前目录名加上，但是还是要自己手动加上的）。这个bug找了我30min。</p>
<img src="/2024/01/22/NYU_OS/image-14.png" class="" title="alt text">
<p>ans: 在找到发现另一个目录前，请把目录名append到源路径后面并且加上‘&#x2F;’。<br>e.g. : 如果源路径是<code>./filesystem</code>，如果你在其中发现了一个dir，那么就是<code>./filesystem/&lt;dirname&gt;</code>.</p>
</li>
<li><p>我神奇的静态示例一直把strcmp看成strcpy，内存反复爆炸。。。下次看到这种内存写</p>
<img src="/2024/01/22/NYU_OS/image-15.png" class="">
<p>的错误大概就是strcpy这种写入方程的参数错误了，大概率是往指针里写。。所以最好还是定义成const预防一下。。（没想到之前书里看到了错误自己全部踩了一遍。。</p>
</li>
</ul>
<p>神奇之处：</p>
<ul>
<li>在root文件夹中的<code>..</code>并不是上一级目录，而是他自己，自己指向了自己。</li>
</ul>
<p>感受：</p>
<ul>
<li><p>最绝望的时候通常是无路可走的时候，而不是有一条艰辛的路的时候。前者像是在等死，后者有希望。但是在我相信在之后系统开发的过程中一定会有更看不懂的bug出现，而让自己成为编译器是不可能的，尽自己全力掌握debug tricks并汲取经验好好成长才是可行之道。心态是 — 在找bug的时候一定要相信是自己的问题，而这种问题绝对是可以被解决的。</p>
</li>
<li><p>如何debug：尽可能地在自己能确认的地方打log。ex：看前面两行就是我在理解getopt这个api的时候加入的log，这样其实更加清晰，少了自己人肉编译的过程。所以这种方便自己理解的log越多越好。。</p>
<img src="/2024/01/22/NYU_OS/image-16.png" class="" title="alt text">
<img src="/2024/01/22/NYU_OS/image-17.png" class="" title="alt text"></li>
</ul>
<p>基本逻辑打好了，现在剩下</p>
<ul>
<li>重新看一遍lab2，了解test（bats）的framework。</li>
<li>优化<ul>
<li>-n有无更好的方法?</li>
<li>overflow的问题。（字符串怎么使用的更好）</li>
<li>recursive？检查。</li>
<li>其余代码检查</li>
</ul>
</li>
</ul>
<p><em>2024&#x2F;02&#x2F;12</em><br>没想到下一次写lab居然是一周之后了啊。。。上周实在是太水了。。</p>
<h4 id="Testing-framework"><a href="#Testing-framework" class="headerlink" title="Testing framework"></a>Testing framework</h4><p>mktest.sh</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">TEST_DIR=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$&#123;TEST_DIR&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Cowardly refusing to change an existing directory <span class="variable">$&#123;TEST_DIR&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Create base directory.</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$&#123;TEST_DIR&#125;</span></span><br><span class="line"><span class="comment"># Create some files.</span></span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/a</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/b</span><br><span class="line"><span class="built_in">touch</span> -t 1912301230.03 <span class="variable">$&#123;TEST_DIR&#125;</span>/c</span><br><span class="line"><span class="built_in">touch</span> -t 1810251600.00 <span class="variable">$&#123;TEST_DIR&#125;</span>/d</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=<span class="variable">$&#123;TEST_DIR&#125;</span>/s1 bs=1024 count=1 status=none &gt; /dev/null</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=<span class="variable">$&#123;TEST_DIR&#125;</span>/s2 bs=1024 count=2 status=none &gt; /dev/null</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=<span class="variable">$&#123;TEST_DIR&#125;</span>/s3 bs=1024 count=3 status=none &gt; /dev/null</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=<span class="variable">$&#123;TEST_DIR&#125;</span>/s4 bs=1024 count=4 status=none &gt; /dev/null</span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/in0</span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/in0/in1</span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/in0/in1/in2</span><br><span class="line"><span class="built_in">touch</span> -t 1912301230.03 <span class="variable">$&#123;TEST_DIR&#125;</span>/in0/a</span><br><span class="line"><span class="built_in">touch</span>  <span class="variable">$&#123;TEST_DIR&#125;</span>/in0/b</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/in0/in1/in2/x</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/.boo</span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/bad</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/bad/bad_user</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> 2002 <span class="variable">$&#123;TEST_DIR&#125;</span>/bad/bad_user</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/bad/bad_group</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> :2220 <span class="variable">$&#123;TEST_DIR&#125;</span>/bad/bad_group</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/bad/bad_ugroup</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> 2002:2220 <span class="variable">$&#123;TEST_DIR&#125;</span>/bad/bad_ugroup</span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/.hidden</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/.hidden/a</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/.hidden/b</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/.hidden/c</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/ungrwx</span><br><span class="line"><span class="built_in">chmod</span> 070 <span class="variable">$&#123;TEST_DIR&#125;</span>/ungrwx</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/urwxgn</span><br><span class="line"><span class="built_in">chmod</span> 700 <span class="variable">$&#123;TEST_DIR&#125;</span>/urwxgn</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/urwgrwarw</span><br><span class="line"><span class="built_in">chmod</span> 666 <span class="variable">$&#123;TEST_DIR&#125;</span>/urwgrwarw</span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$&#123;TEST_DIR&#125;</span>/urwgrar</span><br><span class="line"><span class="built_in">chmod</span> 644 <span class="variable">$&#123;TEST_DIR&#125;</span>/urwgrar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_ls lab用时约12小时_。</p>
<h2 id="Lecture-5-6-7-8-Concurrency-I-II-III-IV"><a href="#Lecture-5-6-7-8-Concurrency-I-II-III-IV" class="headerlink" title="Lecture 5&#x2F;6&#x2F;7&#x2F;8: Concurrency I&#x2F;II&#x2F;III&#x2F;IV"></a>Lecture 5&#x2F;6&#x2F;7&#x2F;8: Concurrency I&#x2F;II&#x2F;III&#x2F;IV</h2><p>在介绍处理并行的方法前，先介绍一个常见的硬软件错误：</p>
<p>Q1：Can data be called with 0?<br>assumption:</p>
<ol>
<li>compiler produce sequential code</li>
<li>single cpu</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data = <span class="number">0</span>, ready = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">()</span> &#123;</span><br><span class="line">    data = <span class="number">2000</span>;</span><br><span class="line">    ready = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">p2</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;&#125;</span><br><span class="line">    <span class="comment">// can data be called with 0?</span></span><br><span class="line">    use(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/22/NYU_OS/image-22.png" class="" title="alt text">

<p>Mike：这个例子并不会出现在单核cpu中，介绍这个example只是为了介绍concurrency的真正问题不只是存在程序员的设计的threadprogramming中，并且存在硬件中（multicore）。但是之后介绍的control primitives会优雅地解决这些硬软件并行问题。</p>
<h3 id="第一个措施：lock"><a href="#第一个措施：lock" class="headerlink" title="第一个措施：lock"></a>第一个措施：<strong>lock</strong></h3><p><strong>note：注意虽然被夹在lock中间的代码是“atomic”，但是实际上他们的执行顺序依旧是不固定的，取决于scheduler。</strong></p>
<p>也就是说acquire() 和release() 之间，只能有一个thread running。</p>
<p>锁的作用是配合了programmer设计的invariant。他能保证“某些shared memory中”会被executed atomicaly, 保证了invariant的正确性。</p>
<p><strong>lock的机制</strong>：</p>
<ul>
<li>if a lock wants to acquire a lock: it needs to wait for the lock to be unlocked by some other threads.</li>
<li>only the thread who acquire the lock can unlock it.</li>
</ul>
<img src="/2024/01/22/NYU_OS/image-30.png" class="" title="alt text">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_tlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">x= x + <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<img src="/2024/01/22/NYU_OS/image-5.png" class="" title="alt text">
<p>小问题：为什么这里的yield()还要require() 和acquire()？<br>因为如果一个进程似了，他还拿着lock，别的进程如果要进入critical section，只能陪它一起似了。（当然，更好的还是使用wait primitive）</p>
<h3 id="第二个措施：cv"><a href="#第二个措施：cv" class="headerlink" title="第二个措施：cv"></a>第二个措施：<strong>cv</strong></h3><p><strong>Why do we learn Conditional variable?</strong></p>
<ul>
<li>通常是因为两个thread之间有dependency形成了一种拓补关系。</li>
<li>但是通常的spin等待太铸币了，需要一种硬件上的解决方式，直接让thread sleep。</li>
</ul>
<p>因此就有了以下的api。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intpthread_cond_wait(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex);</span><br><span class="line">intpthread_cond_signal(<span class="type">pthread_cond_t</span> *cond);</span><br></pre></td></tr></table></figure>

<p>一个thread执行的状态有：</p>
<ol>
<li>sleep：似了。CPU不管这个，省clock cycle。</li>
<li>ready：被lock挡住了。CPU不管这个，省clock cycle。要么是被wait之后叫醒，要么是要锁的时候被block了，但是已经排在queue中了。如果锁一开，有可能哥们直接上。</li>
<li>run：正在跑的thread。<br><strong>multithread的目的：就是让parallelism好好执行&#x2F; 但是不让相关逻辑的critical section影响。</strong></li>
</ol>
<ul>
<li>wait：一个thread觉得自己进行不下去了，release自己的lock（这也是为什么wait要带一个mutex作为argument的原因）然后hold一个约定（conditional variable）。</li>
<li>signal：另一个thread想要唤醒持有规约的那个睡觉的thread（可能有很多个）。</li>
</ul>
<ul>
<li><p>为什么要有done？<br>ans：如果没有，若signal比wait先call，那么父进程会永远进入睡眠。所以我们要维护一个状态变量（in this case，it is <code>done</code>）</p>
</li>
<li><p>为什么signal的时候还是要有lock？<br>ans：下面的例子：child会再parent执行公务的时候，sleep的时候，立马interupt，然后把done给改了。这样当parent搞完sleep之后，会发现他永远wait了。这是一个围绕signal wait的race condition。所以我们要做的是在</p>
<ul>
<li>parent: check done之前，wait之后</li>
<li>child：改done之前，signal之后。</li>
</ul>
</li>
</ul>
<ol>
<li>either child先执行完，parent发现了已经done了。</li>
<li>or parent先执行完，child在中途signal。</li>
</ol>
<p>这是一个好的synchronization。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span>  c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: begin\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    done = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: signal\n&quot;</span>);</span><br><span class="line">    Cond_signal(&amp;c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    Mutex_lock(&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: check condition\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (done == <span class="number">0</span>) &#123;</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: wait to be signalled...\n&quot;</span>);</span><br><span class="line">	Cond_wait(&amp;c, &amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">    Mutex_unlock(&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>为什么这里是while包住？<br>ans:</p>
<img src="/2024/01/22/NYU_OS/image-23.png" class="" title="alt text">
<p>仔细观察，如果c1在buffer空的时候wait了，之后因为buffer被p1填满进入了ready状态。如果锁之后开了第一个被唤醒的是这个蠢蠢欲动的，但是无处可拿（因为buffer空）的c1，那么是不是很尴尬？因此我们要在wait唤醒之后继续进行while check。</p>
</li>
<li><p>为什么要使用不同的conditional variable？</p>
<img src="/2024/01/22/NYU_OS/image-26.png" class="" title="alt text">
<p>ans: 会导致如上的consumer唤醒consumer的情况，这样我们就进入了死process中。我们需要让conditional variable具有指向性，让合理的逻辑动起来。</p>
<img src="/2024/01/22/NYU_OS/image-27.png" class="" title="alt text"></li>
</ul>
<p>note in class:</p>
<ul>
<li>why wait() releases mutex and goes into waiting states atomically?</li>
</ul>
<p><strong>ans</strong>: if not, when mutex is released, the other thread can executes immediately and signals, so when current thread tries to wait, it will always in waiting state.</p>
<ul>
<li>Will it be good to replace broadcast with signal?</li>
</ul>
<p><strong>ans</strong>: Since we want multiple threads qualified to work together.</p>
<h3 id="Combined-primitive-monitor"><a href="#Combined-primitive-monitor" class="headerlink" title="Combined primitive: monitor"></a>Combined primitive: monitor</h3><p><em>SKIP</em></p>
<h3 id="一些练习。"><a href="#一些练习。" class="headerlink" title="一些练习。"></a>一些练习。</h3><h3 id="Implementation-of-lock"><a href="#Implementation-of-lock" class="headerlink" title="Implementation of lock"></a><strong>Implementation of lock</strong></h3><p>Perterson’s algorithm? See textbook.</p>
<p>Disable Interrupts? Not work for multicpu.</p>
<p>Note: User cannot turn off interrupts because of monopolizing the resources.</p>
<p>critiria:</p>
<ul>
<li>mutual exclusion.</li>
<li>fairness: 所有ready threads都能有相等的机会被唤醒吗？</li>
<li>performance。</li>
</ul>
<h3 id="spin-lock"><a href="#spin-lock" class="headerlink" title="spin lock"></a>spin lock</h3><p>我们用硬件提供的testandset可以写个spinlock.</p>
<p>相当于：我们用了一个隐形的硬件锁同时完成了比较和赋值。</p>
<p>testandset:</p>
<ol>
<li>get oldval</li>
<li>return oldval</li>
<li>setnewval into oldval</li>
</ol>
<p>你也可以用更加强大的comandset。<br>testandset(*oldptr, testval, newval)</p>
<ol>
<li>get oldval from oldptr</li>
<li>return oldval</li>
<li>if oldVal &#x3D;&#x3D; testVal, setnewval into oldptr, else do nothing.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125; <span class="type">lock_t</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using testandset.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (testandset(lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin()</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock-&gt;flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using compareandset.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (compareandset(lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin()</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock-&gt;flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有彩票lock, 用的是fetchandadd primitive<br>fetchandadd:</p>
<ol>
<li>fetch from oldptr</li>
<li>add one to it</li>
<li>return oldval</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> turn;</span><br><span class="line">    <span class="type">int</span> ticket;</span><br><span class="line">&#125; <span class="type">lock_t</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using fetchandadd.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (fetchandadd(lock-&gt;ticket) != lock-&gt;turn) &#123;</span><br><span class="line">        <span class="comment">// spin()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;turn ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mutual exclusive? yes<br>fair? yes since every locked thread is in a queue.<br>performance? still no because of spinning.</p>
<p>一个较为符合直觉的方法是与其spin不如直接让cpu停用那个thread。</p>
<p>cpu -&gt; thread1<br>cpu -context switch–&gt; thread2<br>yield()<br>thread2 go into ready state.<br>cpu -context switch–&gt; thread1<br>thread1 running.</p>
<p>但是它的cost依旧很高因为context switches。</p>
<h3 id="spinlock-–-Lecture-stuff"><a href="#spinlock-–-Lecture-stuff" class="headerlink" title="spinlock – Lecture stuff"></a>spinlock – Lecture stuff</h3><p>xchg –&gt; load and store atomically</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Spinlock</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> locked;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(Spinlock *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin ;</span></span><br><span class="line">        <span class="keyword">if</span> (xchg_val(&amp;lock-&gt;locked, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(Spinlock *lock)</span> &#123;</span><br><span class="line">    lock-&gt;locked = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When two threads try to acquire the lock (write 1 to a lock):</p>
<p>only read a 0 —&gt; can proceed.</p>
<p>only one will read 0 and write 1 at a time.</p>
<h3 id="Spinlock-based-mutex"><a href="#Spinlock-based-mutex" class="headerlink" title="Spinlock-based mutex"></a>Spinlock-based mutex</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mutex</span> &#123;</span></span><br><span class="line">    <span class="comment">// helper</span></span><br><span class="line">    <span class="type">thread_t</span> *owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue of threads that wait the lock -- ensrues fairness</span></span><br><span class="line">    STAILQ(<span class="type">thread_t</span>) waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensures atomicity</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Spinlock</span> <span class="title">splock</span>；</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">acquire</span>(<span class="keyword">struct</span> <span class="title">Mutex</span> *<span class="title">m</span>) &#123;</span></span><br><span class="line">    acquire(&amp;m-&gt;splock);</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;owner == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if no one waiting, i admit it.</span></span><br><span class="line">        m-&gt;owner = tid_of_this_thread;</span><br><span class="line">        release(&amp;m-&gt;splock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if someone owns it, i wait</span></span><br><span class="line">        <span class="comment">// it is the scheduler that actually blocks</span></span><br><span class="line">        sched_mark_blocked(&amp;id_of_this_thread);</span><br><span class="line">        release(&amp;m-&gt;splock);</span><br><span class="line">        sched_swtch();</span><br><span class="line">        <span class="comment">// continue executes when waking up</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> Mutex *m)</span> &#123;</span><br><span class="line">    acquire(&amp;m-&gt;splock);</span><br><span class="line">    <span class="comment">// owner must be in critial section</span></span><br><span class="line">    <span class="comment">// because owner will be waked all at once.</span></span><br><span class="line"></span><br><span class="line">    m-&gt;owner = STALIQ_GET_HEAD(&amp;m-&gt;waiters);</span><br><span class="line">    <span class="comment">// if we do get some waiting thread, wake that thread, since</span></span><br><span class="line">    <span class="comment">// invariant here is all the waiters are sleeping in perspective of scheduler.</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;owner) &#123;</span><br><span class="line">        sched_wake(&amp;m-&gt;owner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// And that is officially executing</span></span><br><span class="line">        STALIQ_REMOVE_HEAD(&amp;m-&gt;waiters);</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;m-&gt;splock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HW-3-4-5"><a href="#HW-3-4-5" class="headerlink" title="HW 3&#x2F;4&#x2F;5"></a>HW 3&#x2F;4&#x2F;5</h2><h3 id="1-The-uses-of-threading"><a href="#1-The-uses-of-threading" class="headerlink" title="1. The uses of threading"></a>1. The uses of threading</h3><p>“For a given workload, a multi-threaded process has lower time-to-completion than the equivalent single-threaded process.” Explain your answer in 2-3 sentences.</p>
<p><strong>ans</strong>: Depends on how the overhead-synchrnozation takes.<br>single cpu: multithread &lt; single thread<br>multiple cpu: multithread (maybe) &gt; single thread because of parallelism.</p>
<h3 id="2-practice"><a href="#2-practice" class="headerlink" title="2. practice"></a>2. practice</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ADD SOME THINGS HERE */</span></span><br><span class="line">mutex</span><br><span class="line">cond</span><br><span class="line"><span class="type">bool</span> if_foo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">foo</span><span class="params">(<span class="type">void</span> *)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am foo!!!\n&quot;</span>);</span><br><span class="line">    if_foo = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// if_foo 必须在signal前面为了防止死机。</span></span><br><span class="line"></span><br><span class="line">    signal(cond, mutex);</span><br><span class="line">    <span class="comment">/* ADD SOME CODE HERE */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">boo</span><span class="params">(<span class="type">void</span> *)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ADD SOME CODE HERE */</span></span><br><span class="line">    <span class="keyword">while</span> (!if_foo) &#123;</span><br><span class="line">        wait(cond, mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am boo!!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    create_thread(foo);</span><br><span class="line">    create_thread(boo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for threads to finish</span></span><br><span class="line">    <span class="comment">// before exiting</span></span><br><span class="line">    join_thread(foo);</span><br><span class="line">    join_thread(boo);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Time-of-check-to-time-of-use-TOCTTOU-bugs"><a href="#3-Time-of-check-to-time-of-use-TOCTTOU-bugs" class="headerlink" title="3. Time-of-check-to-time-of-use (TOCTTOU) bugs"></a>3. Time-of-check-to-time-of-use (TOCTTOU) bugs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">transferBob2Alice</span><span class="params">(<span class="type">double</span> trans)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (bob_balance &gt; trans) &#123;</span><br><span class="line">    smutex_lock(&amp;mtx);</span><br><span class="line">    bob_balance = bob_balance - trans;</span><br><span class="line">    alice_balance = alice_balance + trans;</span><br><span class="line">    smutex_unlock(&amp;mtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lock should be outside.</li>
<li>interleaving: pass if twice?</li>
</ul>
<h3 id="4-Deadlock"><a href="#4-Deadlock" class="headerlink" title="4. Deadlock"></a>4. Deadlock</h3><p>The bank decides to use fine-grained locking. Here is its implementation:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">2</span>]; <span class="comment">// 0 for alice, 1 for bob</span></span><br><span class="line"><span class="type">smutex_t</span> mtx[<span class="number">2</span>];    <span class="comment">// 0 for alice, 1 for bob</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> trans)</span> &#123;</span><br><span class="line">  smutex_lock(&amp;mtx[from]);</span><br><span class="line">  smutex_lock(&amp;mtx[to]);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (balance[from] &gt; trans) &#123;</span><br><span class="line">    balance[from] = balance[from] - trans;</span><br><span class="line">    balance[to] = balance[to] + trans;</span><br><span class="line">    result = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  smutex_unlock(&amp;mtx[to]);</span><br><span class="line">  smutex_unlock(&amp;mtx[from]);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>to ensure correctness of the mutex acquires –</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure the order is from large to small.</span></span><br><span class="line"><span class="keyword">if</span> (from &gt; to) &#123;</span><br><span class="line">    smutex_lock(from)</span><br><span class="line">    smutex_lock(to)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// to &gt; frome</span></span><br><span class="line">    smutex_lock(to)</span><br><span class="line">    smutex_lock(from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Priority-Inversion"><a href="#5-Priority-Inversion" class="headerlink" title="5. Priority Inversion"></a>5. Priority Inversion</h3><p>前提条件是：</p>
<ul>
<li>The system runs one task a time (so assume a single CPU).</li>
<li>All three tasks are begun before the first task ends.</li>
<li>If a task with higher priority is ready to run, it will preempt the running task (note that if a thread is waiting on a mutex that is owned by another thread, then the waiting thread is NOT ready to run!)， 所以scheduler会直接跑最高优先级的，假设这是个完全不fair的scheduler。</li>
<li>Preemption can happen inside the critical section (just as when you code using mutexes in application space).</li>
<li>If a thread cannot continue (for example because it is waiting for a mutex), it yields.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">smutex_t</span> res;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">highPriority</span><span class="params">()</span> &#123;</span><br><span class="line">  ... <span class="comment">// do something</span></span><br><span class="line">  smutex_lock(&amp;res);</span><br><span class="line">  ... <span class="comment">// handle resource</span></span><br><span class="line">  smutex_unlock(&amp;res);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mediumPriority</span><span class="params">()</span> &#123;</span><br><span class="line">  ... <span class="comment">// do something</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;B &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lowPriority</span><span class="params">()</span> &#123;</span><br><span class="line">  smutex_lock(&amp;res);</span><br><span class="line">  ... <span class="comment">// handle resource</span></span><br><span class="line">  smutex_unlock(&amp;res);</span><br><span class="line">  ... <span class="comment">// do something</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;C &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ans</strong>：<br>这一题 – 阐释了一个倒霉蛋high-priority依旧因为lock被反超的故事。<br>因为它assume了三个threads已经同时开始：</p>
<ul>
<li>如果A比C快一步先跑完 –&gt; 拿到锁之后然后跑B再跑C。</li>
<li>如果C比A先拿到锁 –&gt; B接着跑 –&gt; 然后是A –&gt; 然后是C.</li>
</ul>
<h3 id="6-Reader-Writer-Spinlock-Challenge"><a href="#6-Reader-Writer-Spinlock-Challenge" class="headerlink" title="6. Reader Writer Spinlock (Challenge)"></a>6. Reader Writer Spinlock (Challenge)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we are giving you the code for the first of the four functions:</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">reader_acquire</span><span class="params">(<span class="keyword">struct</span> sharedlock* lock)</span> &#123;</span><br><span class="line">   <span class="type">int</span> curr_val;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// spin while a writer owns the lock</span></span><br><span class="line">     <span class="keyword">while</span> ((curr_val = lock-&gt;value) == <span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">     assert(curr_val &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// try to atomically increment the count, based on our best</span></span><br><span class="line">     <span class="comment">// guess of how many readers there had been. if we were</span></span><br><span class="line">     <span class="comment">// wrong, keep looping. if we got it right, then we</span></span><br><span class="line">     <span class="comment">// succeeded in incrementing the count atomically, and we</span></span><br><span class="line">     <span class="comment">// can proceed.</span></span><br><span class="line">     <span class="keyword">if</span> (cmpxchg_val(&amp;lock-&gt;value, curr_val, curr_val + <span class="number">1</span>) == curr_val)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// lock-&gt;value now contains curr_val + 1</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">read_release</span><span class="params">(<span class="keyword">struct</span> sharedlock* lock)</span> &#123;</span><br><span class="line">   atomic_decrement(&amp;lock-&gt;value);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">writer_acquire</span><span class="params">(<span class="keyword">struct</span> sharedlock* lock)</span> &#123;</span><br><span class="line">   <span class="comment">// if it does not equal to 0, just spin.</span></span><br><span class="line">   <span class="keyword">while</span> (cmpxchg_val(&amp;lock-&gt;value, curr_val, <span class="number">-1</span>) != <span class="number">0</span>) &#123;&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">writer_release</span><span class="params">(<span class="keyword">struct</span> sharedlock* lock)</span> &#123;</span><br><span class="line">   xchg_val(&amp;lock-&gt;value, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个典型的c-bug"><a href="#一个典型的c-bug" class="headerlink" title="一个典型的c bug"></a>一个典型的c bug</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert box: places the box &quot;inner&quot; inside of the box &quot;outer&quot;.</span></span><br><span class="line"><span class="comment">// Since &quot;outer&quot; is being modified, we pass a pointer to &quot;outer&quot;.</span></span><br><span class="line"><span class="comment">// Since &quot;inner&quot; is not being modified, we pass in &quot;inner&quot; directly.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_box</span><span class="params">(<span class="keyword">struct</span> box* outer, <span class="keyword">struct</span> box inner)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;insert box: placing id %d inside id %d\n&quot;</span>, inner.id, outer-&gt;id);</span><br><span class="line">    outer-&gt;inner_box = &amp;inner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ans</strong>: The struct box inner lives on the <em>stack</em> and will go out of scope when the function returns.</p>
<h2 id="Lecture-9-Therac-25"><a href="#Lecture-9-Therac-25" class="headerlink" title="Lecture 9 Therac 25"></a>Lecture 9 Therac 25</h2><h2 id="Lecture-10-Scheduler"><a href="#Lecture-10-Scheduler" class="headerlink" title="Lecture 10 Scheduler"></a>Lecture 10 Scheduler</h2><p>processes有以下几种状态，简洁明了不多说了：</p>
<ul>
<li>ready：就是scheler的候选。</li>
<li>running：cpu在跑它。</li>
<li>waiting：反正就是在等一个状态，非常像thread在等一个condition variable的状态。<img src="/2024/01/22/NYU_OS/image-29.png" class="" title="alt text"></li>
</ul>
<p>以下是preemptive的scheduler。</p>
<img src="/2024/01/22/NYU_OS/image-31.png" class="" title="alt text">

<p>nonpreemptive-preemptive的scheduler：只会在process wait或者exit的时候做出选择，否则就一直死磕在一个process上。</p>
<p>最简单的例子：<strong>FIFO</strong><br>throughput: always 0.1, (number of processes) &#x2F; time &#x3D; 3 &#x2F; 30 &#x3D; 0.1s<br>avg turnaround time &#x3D; time (first 1, then 2, then 3) &#x3D; time &#x2F; processes &#x3D; (24 + 27 + 30) &#x2F; 3 &#x3D; 27s</p>
<img src="/2024/01/22/NYU_OS/image-32.png" class="" title="alt text">

<p>例子：<strong>SJF</strong></p>
<img src="/2024/01/22/NYU_OS/image-33.png" class="" title="alt text">

<p>例子：<strong>Round Robin</strong></p>
<img src="/2024/01/22/NYU_OS/image-34.png" class="" title="alt text">
<p>这个问题是：太长了导致就失去了协调工作的特性，导致turnaround time太长了，太短了也会导致context switch的成本变大很多。</p>
<p>加入以下的机制：I&#x2F;O<br>Intuition是：大多数时间个人用户不会拿电脑来一直做computational intensive的工作，而是和互联网交互，等待文件传输，邮件，code editing等等。（一个例子就是vscode）</p>
<p>我们进行以下分析：disk utilization – Scheduler的决策怎么影响到disk使用率的。</p>
<img src="/2024/01/22/NYU_OS/image-35.png" class="" title="alt text">

<p>FIFO明显不行：等的太久了。</p>
<p>RR(100ms&#x2F;break)明显不行：disk utilization &#x3D; 5%.</p>
<p>RR(1ms&#x2F;break)行：disk utilization &#x3D; 10&#x2F;11 &#x3D; 90%.<br>——————–IO————-10ms ————————————————<br>A(1ms) -&gt; B(1ms) -&gt; C(1ms) -&gt; A(1ms) -&gt; B(1ms) -&gt; c waiting -&gt; … A -&gt; B-&gt;… -&gt; c</p>
<p>SJF行：disk utilization &#x3D; 10&#x2F;11 &#x3D; 90%.</p>
<img src="/2024/01/22/NYU_OS/image-36.png" class="" title="alt text">

<h2 id="Lecture-11-12-13-15-Virtual-Memory-I-II-III-IV"><a href="#Lecture-11-12-13-15-Virtual-Memory-I-II-III-IV" class="headerlink" title="Lecture 11&#x2F;12&#x2F;13&#x2F;15 Virtual Memory I&#x2F;II&#x2F;III&#x2F;IV&#x2F;"></a>Lecture 11&#x2F;12&#x2F;13&#x2F;15 Virtual Memory I&#x2F;II&#x2F;III&#x2F;IV&#x2F;</h2><img src="/2024/01/22/NYU_OS/image-37.png" class="" title="alt text">
<p>_掺杂一些小想法_：<br>Mike在课程中反复的用戏谑的语气来嘲讽fullstack的一些工作，我从中其实也感觉也是。现实就是发展越来越快的世界并不需要多高的智商就能做的一些事情就能赚到钱。不过我总的来说高智商歧视蛮有毒的，大家各取所需，过好自己的生活就行了吗。</p>
<p>但不可否认的是，对我来说，理解这些底层逻辑对我有一种自然的快乐感，我想这就是好奇心被满足的感觉吧。类似的感觉也出现在初探CSAPP，理解计网的大概逻辑的时刻，理解这些伟大设计让我感到愉悦。</p>
<p>迫于生活大多数人都大概率是会去做那些简单无趣但是又重要的工作，所以放平心态吧 – 仅仅为了愉悦和内功去选择这些系统课吧！</p>
<p><em>我其实觉得其实是CSAPP chap9的总结。。</em><br>a. <strong>万物之初</strong>：</p>
<img src="/2024/01/22/NYU_OS/image-49.png" class="" title="alt text">

<ul>
<li>因此，CPU在每次fetch execute的时候都要做一次翻译。</li>
</ul>
<p>VM好处：</p>
<ul>
<li>不用担心physical mem的分配，VM是自动化的。</li>
</ul>
<p>b. <strong>有了页表之后。。</strong></p>
<img src="/2024/01/22/NYU_OS/image-48.png" class="" title="alt text">
<p>这个世界很天真：</p>
<ol>
<li>首先判断是不是NULL，就是啥也没有的</li>
<li>如果没有，kernel会更新自己的页表，先让页表存储这个映射。</li>
<li>缺页和命中页：<ol>
<li>MMU首先判断valid bit，确认是否缓存在RAM中。</li>
<li>如果hit，那就hit，直接从RAM中取。</li>
<li>如果发生缺页，内核缺页程序会被调用，在RAM中牺牲一个页，从disk上缓存过来。</li>
</ol>
</li>
</ol>
<p><strong>Note</strong>: 局部性works well, 因为用户程序基本只会在一小部分的addr上来回使用，确保他们在一小部分的虚拟页来回使用。<br>note: thrashing(抖动)，页面换进换出，导致的性能下降。</p>
<p>c. <strong>引入进程隔离</strong>：</p>
<img src="/2024/01/22/NYU_OS/image-51.png" class="" title="alt text">
<p>好处：</p>
<ul>
<li>加载：这层内存的抽线简化很多kernel程序的实现：linux加载器可以直接做一个内存从虚拟地址的.text和.data区域中映射到磁盘上的文件位置。</li>
<li>共享：大家可以同时指向同一块pa，比如OS的metadata。使得用户可以更加直接的access到os。</li>
<li>链接：本质是规范了内存空间的格式，每个process的内存的结构都几乎一样了，比如stack，heap，代码总是从0x400000开始。。。</li>
</ul>
<p>d. <strong>内存保护</strong></p>
<img src="/2024/01/22/NYU_OS/image-50.png" class="" title="alt text">

<ul>
<li>引入在PTE上的bit，使得用户无法随便access敏感数据。</li>
</ul>
<h3 id="页表是怎么工作的-kernel中的代码逻辑是什么样的？"><a href="#页表是怎么工作的-kernel中的代码逻辑是什么样的？" class="headerlink" title="页表是怎么工作的 &lt;&#x3D;&#x3D;&gt; kernel中的代码逻辑是什么样的？"></a>页表是怎么工作的 &lt;&#x3D;&#x3D;&gt; kernel中的代码逻辑是什么样的？</h3><p>首先看看理论，在大脑中过一遍：<br><a href="vm-csapp.pdf">vm-csapp.pdf</a></p>
<img src="/2024/01/22/NYU_OS/image-52.png" class="" title="alt text">
<p>a. <strong>引入TLB</strong></p>
<ul>
<li>简单来说就是PTE的cache，如上所示，我们也有PTE找不到的情况。在这个时候就必须得从disk中找到存储PTE的地方fetch回来，如果是RAM的话会稍慢一点，但是如果是disk就慢得多了。但是这样显然不如一个更快的存储单元靠近MMU来cache一部分PTEs。<img src="/2024/01/22/NYU_OS/image-53.png" class="" title="alt text"></li>
</ul>
<ol>
<li>先在TLB找。</li>
<li>如果没有就从cache&#x2F;disk找，fetch回TLB，并且返回给MMU。</li>
</ol>
<p>b. <strong>引入多级页表</strong></p>
<img src="/2024/01/22/NYU_OS/image-54.png" class="" title="alt text">
<p>怎么work不讲了，讲讲设计哲学：</p>
<ul>
<li>树状结构减轻了存储压力，如果没有需求就完全不会有未分配页。</li>
<li>加速：只有一级页表需要一直在RAM中，和经常使用的次级页表RAM，这样可以更快的fetch数据。</li>
</ul>
<p>Notes：</p>
<ul>
<li><p>%cr3 is the address of the top-level directory, 是<strong>Physical address</strong>, 如果是VA的话，那岂不是自己也要通过一个pagetable去做翻译？这显然是错的。</p>
</li>
<li><p>Bits</p>
<img src="/2024/01/22/NYU_OS/image-55.png" class="" title="alt text">
</li>
<li><p>size</p>
<blockquote>
<p>–each entry in the L1 page table corresponds to 512GB of virtual address space (“corresponds to” means “selects the next-level page tables that actually govern the mapping”).<br>–each entry in the L2 page table corresponds to 1 GB of virtual address space<br>–each entry in the L3 page table corresponds to 2 MB of virtual address space<br>–each entry in the L4 page table corresponds to 1 page (4 KB) of virtual address space</p>
</blockquote>
</li>
<li><p>作为os使用者，我们能调整pagesize大小吗？</p>
<pre><code>  Can get 2MB (resp, 1 GB pages) on x86: each L3 (resp, L2) page
  table now points to the page instead of another page table

  + page tables smaller, less page table walking

  - more wasted memory

  to enable this, set bit 7 (PS) bit

  example: set bit PS in L3 table
      result is 2MB pages
      page walking is L1, L2, L3; no L4 page tables
</code></pre>
</li>
<li><p>What is the minimum number of physical pages required on x86-64 to allocate the following allocations? Draw an example pagetable mapping for each scenario (start from scratch each time).</p>
</li>
</ul>
<p><strong>Question</strong>: 2^18 + 1 allocations of size 2^12 bytes of memory each</p>
<p><strong>ans</strong>:</p>
<ul>
<li>(2^18 + 1) data pages</li>
<li>(ROUNDUP(2^18 + 1, PAGESIZE) &#x2F; 2^9) &#x3D; 2^9 + 1 level 4 pages</li>
<li>(ROUNDUP(2^9 + 1, PAGESIZE) &#x2F; 2^9) &#x3D; 2 level 3 pages</li>
<li>1 for level 2</li>
<li>1 for level 1</li>
</ul>
<p><strong>all</strong> &#x3D; [1 (L1) + 1 (L2) + 2 (L3) + (2^9 + 1) (L4) + (2^18 + 1) (the memory)] ]</p>
<p>c. <strong>Page fault: kernel的介入</strong>。</p>
<ol>
<li>什么时候发生？ <strong>ans</strong>:<ol>
<li>PTE没找到的时候，invalid</li>
<li>protection被激活的时候，只读page被写的时候。</li>
</ol>
</li>
<li>怎么发生？<br>–processor constructs a trap frame and transfers execution to an interrupt or trap handler</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    ss     [stack segment; ignore]</span><br><span class="line">    rsp    [former value of stack pointer]</span><br><span class="line">    rflags [former value of rflags]</span><br><span class="line">    cs     [code segment; ignore]</span><br><span class="line">            rip    [instruction that caused the trap]</span><br><span class="line">%rsp --&gt; [error code]</span><br></pre></td></tr></table></figure>

<p>用一个trapframe，然后调用程序。注意最后的rip是指向的导致调用的code。所以当我们回去执行那行cause fault的代码的时候，handler理应完成任务了。</p>
<p>Note: <code>%cr2</code>是存了产生page fault的register. 3. Uses<br>_ large memory: 这也是VM的经典用处，RAM很小的时候给用户一个很大的幻象。page不久就可以塞满RAM的kernel page section的时候，可以调用fault去换page。<br>_ network: 在调用interrupt的handler的时候，我们可以从网上传输page而不是通过disk。* copy-on-write: copy on write是和别的进程一起用pagetable，比如说fork的实现进程2会copy进程1的pagetable并且mark它为只读。如果之后你要写其中一个page，那就触发copy-on-write handler，然后申请一个其他的physical page map一下，改成可写，再写。copy-on-write用了最稀有的RAM！！省空间！！</p>
<ol start="4">
<li><p>Costs? 只有小于1&#x2F;10^6的概率发生page fault才能保证在 10%的performace的损失之内。</p>
</li>
<li><p>Page replacement policies</p>
<ul>
<li><p>Some algor?</p>
<ul>
<li><p><strong>MIN</strong> (also known as OPT). throw away the entry that won’t be used for the longest time. this is optimal.<br>Proof:</p>
<pre><code>  Choose any other scheme. Call it ALT. Now let&#39;s sum the
  number of misses under ALT or OPT, and induct over the
  number of references. Four cases at any given reference:
  &#123;OPT hits, ALT hits&#125;, &#123;OPT hits, ALT misses&#125;, &#123;OPT misses,
  ALT misses&#125;, &#123;OPT misses, ALT hits&#125;.

  In the first three cases, OPT does as well or better than
  ALT, so OPT keeps pace with, or beats, the competition at
  every reference. Now focus on the last case; say that it
  happens at a reference, r. By the induction hypothesis, OPT
  was optimal right up until the *last* miss OPT experienced,
  at reference, say, r - a.  After that reference, there has
  been only one miss (the current one, at r). The alternative,
  ALT, couldn&#39;t have done better than OPT up until r-a (by the
  induction hypothesis). And since r-a, OPT has had only one
  miss. But ALT could not have had 0 misses between r-a and
  now because if it did, it means that OPT replaced the wrong
  entry at r-a (another way to say the same thing: OPT chose
  which page to evict so that a is maximal). Thus, OPT is no
  worse than ALT at r. Since OPT was no worse than ALT at
  every step prior to r, and since there were no constraints
  on ALT (besides not being OPT), then OPT is indeed optimal
  at memory reference r. By induction, OPT is optimal.
</code></pre>
</li>
</ul>
</li>
<li><p>evaluating?</p>
<ul>
<li>number of cache evictions</li>
</ul>
</li>
<li><p>examples</p>
</li>
<li><p>FIFO<img src="/2024/01/22/NYU_OS/image-56.png" class="" title="alt text"></p>
</li>
<li><p>LRU<img src="/2024/01/22/NYU_OS/image-57.png" class="" title="alt text"></p>
</li>
<li><p>Notes:</p>
</li>
<li><p>加了更多的phys_slots并不会代表FIFO会表现的更好。</p>
<img src="/2024/01/22/NYU_OS/image-58.png" class="" title="alt text"></li>
<li><p>LRU – Least recently used Algorithm实现！<br>Notes</p>
<ol>
<li>在set dirty bit的时候并不是真的要在hardware里写这种电路逻辑。而是可以set所有的pages只读，在kernel中的pagefault handler里改成遇到这种就直接set它成可写。</li>
<li>Same for Use bit, 只要set所有的page成不可用就行。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Thrashing</strong>：就是因为内存使用超过了界限导致的page fault变多。</p>
<ul>
<li>解决方案：保持working sets在fixed amount.</li>
</ul>
</li>
</ol>
<h2 id="hw-6-7-8"><a href="#hw-6-7-8" class="headerlink" title="hw 6&#x2F;7&#x2F;8"></a>hw 6&#x2F;7&#x2F;8</h2><p>TODO</p>
<h2 id="Lecture-16-I-O-in-general"><a href="#Lecture-16-I-O-in-general" class="headerlink" title="Lecture 16 I&#x2F;O in general"></a>Lecture 16 I&#x2F;O in general</h2><ol>
<li>I&#x2F;O 总览 &amp;&amp; cpu如何和I&#x2F;O设备进行交互<img src="/2024/01/22/NYU_OS/image-19.png" class="" title="alt text"></li>
</ol>
<p>作为最经典的一个嵌在总线上的通用设备，disk。我们来看看cpu怎么和disk进行互动的。（自然，“我们”指的是kernel）<br>a. explicit I&#x2F;O <strong>instructions</strong> – <code>outb, inb, outw, inw</code>.通过特殊权限的指令集来读写io。</p>
<img src="/2024/01/22/NYU_OS/image-20.png" class="" title="alt text">
<img src="/2024/01/22/NYU_OS/image-59.png" class="" title="alt text">

<p>我们习以为常的敲键盘：也就是interrupt加上读端口的过程，中间都是kernel的软件来handle的。</p>
<img src="/2024/01/22/NYU_OS/image-42.png" class="" title="alt text">

<p>b. Memory mapped I&#x2F;O：Low-memory addresses (650K-1MB) actually refer to other things. 通过特殊的内存映射，by kernel，来直接写入相应的物理内存。</p>
<blockquote>
<p>note: 但是我们不是真的在physical memory 650K-1MB上写东西，而是通过总线操作硬件register，硬件的memory。</p>
</blockquote>
<p><strong>Example</strong>: writing to VGA or CGA memory makes things appear on the screen.</p>
<p>c. interrupt</p>
<p>d. through memory: both CPU and the device see the same memory,so they can use shared memory to communicate.</p>
<ol start="2">
<li>上述代码中，一直使用的是busy waiting，但是cpu如何和I&#x2F;O设备进行交互时候绝不可能浪费cpu的这么多资源。那么，经典tradeoff（如何实现其中的交互？）</li>
</ol>
<p>a. Polling vs. interrupts (vs. busy waiting)</p>
<ul>
<li><p>Polling: check back periodically<br>Disadvantages: wasted CPU cycles (if device not busy) and higher latenc</p>
</li>
<li><p>I&#x2F;O devices —Interrupts—&gt; CPU when its status changes (for example, data is ready, or data is fully written).<br>Disadvantages: livelock. (when cpu receives so many interrupts from io devices, like almost infinite request from network card)</p>
</li>
</ul>
<blockquote>
<p>How to design systems given these tradeoffs? Start with</p>
</blockquote>
<pre><code>    interrupts. If you notice that your system is slowing down
    because of livelock, then switch to polling. If polling is chewing
    up too many cycles, then move towards an adaptive switching
    between interrupts and polling. (But of course, never optimize
    until you actually know what the problem.) A classic reference
    on this subject is the paper
        &quot;Eliminating Receive Livelock in an Interrupt-driven
        Kernel&quot;, by Mogul and Ramakrishnan, 1996.
</code></pre>
<p>b. DMA vs. programmed I&#x2F;O</p>
<ul>
<li>Programmed I&#x2F;O: 就是这个<code>outb, inb, outw, inw</code>。device直接写入cpu。</li>
<li>DMA：通过cpu在RAM中留好的空间，device写入内存中。这通常适用于大文件，比如说大文件从disk传输到RAM中。<img src="/2024/01/22/NYU_OS/image-43.png" class="" title="alt text"></li>
</ul>
<p>device driver： TODO</p>
<ol start="3">
<li>Synchronous vs asynchronous I&#x2F;O<br><strong>Notes</strong>: kernel never blocks when issuing I&#x2F;O. We’re discussing the interface presented to user-level processes.</li>
</ol>
<ul>
<li>blocking interface leads to more readable code, when considering the code that invokes that interface</li>
<li>but blocking interfaces BLOCK, which means that the code <em>above</em> the interface cannot suddenly switch to doing something else. if we want concurrency, it has to be handled by a layer <em>underneath</em> the blocking interface.</li>
</ul>
<ol start="4">
<li>mmap()</li>
</ol>
<img src="/2024/01/22/NYU_OS/image-44.png" class="" title="alt text">

<p><strong>mmap</strong>：功能是 – 直接把磁盘上的内容映射到用户的虚拟空间中，并且返回一个mem ptr.</p>
<blockquote>
<p>the “disk image” here is the file we’ve mmap()’ed, not the process’s usual backing store. The idea is that mmap() lets the programmer “inject” pages from a regular file on disk into the process’s backing store (which would otherwise be part of a swap file).</p>
</blockquote>
<p>mmap的优点是什么？</p>
<ul>
<li>读写省了一步：disk -&gt; ram(buffer cache) -&gt; read to use space（这是省了的那一步） -&gt; write to terminal</li>
</ul>
<p>如何实现：kernel中维护了一个buffer cache，然后kernel做映射从process pagetable的VA到kernel buffer cache的PA中去。这样在user space如果要读一个大文件，直接mmap，就直接可以从kernel buffer中直接读了。</p>
<img src="/2024/01/22/NYU_OS/image-45.png" class="" title="alt text">

<p>更详细的解释大概是这样：</p>
<img src="/2024/01/22/NYU_OS/image-46.png" class="" title="alt text">

<h2 id="Lecture-17-Context-Switch"><a href="#Lecture-17-Context-Switch" class="headerlink" title="Lecture 17: Context Switch"></a>Lecture 17: Context Switch</h2><p><em>5.7：复习os的感觉要比ait好多了。。。有种在学黑魔法的感觉。。</em></p>
<p>Context Switch本身太依赖实现来讲lecture，我就直接post这个ppt了。</p>
<blockquote>
<p>man，what can i say?<br><a href="scribble17.pdf">context-swtich.pdf</a></p>
</blockquote>
<p>黑魔法1：user level thread package是怎么实现的?</p>
<img src="/2024/01/22/NYU_OS/image-61.png" class="" title="alt text">
<img src="/2024/01/22/NYU_OS/image-62.png" class="" title="alt text">

<p>没错，因为thread重要的只有reg。仅仅是通过经典的push pop，当涉及向rsp这样的需要双方thread都要用的reg的时候，则bookkeep一下，借用一下kernel的内存缓存一下在tcb(thread control block中存好)。</p>
<p>黑魔法2：  </p>
<img src="/2024/01/22/NYU_OS/image-60.png" class="" title="alt text">
<p>在user level实现blocking的时候，其实为了性能当然不是真正的blocking拉。</p>
<p>背后还是会swtch一下的。</p>
<h2 id="Lecture-18-Disks"><a href="#Lecture-18-Disks" class="headerlink" title="Lecture 18: Disks"></a>Lecture 18: Disks</h2><hr>
<pre><code>|          platter
| ------------
|
|
| ------------
|          platter
| ------------
    |
|
| ------------
|          platter
| ------------
|  
</code></pre>
<img src="/2024/01/22/NYU_OS/image-63.png" class="" title="alt text">

<p>–a <strong>seek</strong> consists of up to four phases:<br>–<em>speedup</em>: accelerate arm to max speed or half way point<br>–<em>coast</em>: at max speed (for long seeks)<br>–<em>slowdown</em>: stops arm near destination<br>–<em>settle</em>: adjusts head to actual desired track</p>
<img src="/2024/01/22/NYU_OS/image-64.png" class="" title="alt text">

<h3 id="Performance-计算："><a href="#Performance-计算：" class="headerlink" title="Performance 计算："></a>Performance 计算：</h3><ul>
<li>Spindle Speed: 7200 RPM</li>
<li>Avg Seek Time, read&#x2F;write: 10.5ms &#x2F; 12 ms</li>
<li>Maximum seek time: 19ms</li>
<li>Track-to-track seek time: 1ms</li>
<li>Transfer rate (surface to buffer): 54-128 MB&#x2F;s</li>
<li>Transfer rate (buffer to host): 375 MB&#x2F;s*</li>
</ul>
<p>(a) How long would it take to do 500 sector reads, spread out randomly over the disk (and serviced in FIFO order)?</p>
<p><strong>ans</strong>:<br>_一圈多久: 60s&#x2F;1min _ 1 min&#x2F;7200 rotations &#x3D; 8.33 ms<br>*rotation delay（求期望值取平均） &#x3D; 4.165 ms<br>*seek time: 10.5 ms (given)<br>_transfer time: 512 bytes _ 1 s&#x2F;54 MB * 1MB&#x2F;10^6 bytes &#x3D; .0095 ms</p>
<p>_asawhole–oneread &#x3D; 14.66ms<br>ans: (rotation delay + seek time + transfer_time) _ 500 &#x3D; 7.3 seconds</p>
<p>(b) How long would it take to do 500 requests, SEQUENTIALLY on the disk? (FIFO order once more)<br><strong>ans</strong>:<br>_一圈多久: 60s&#x2F;1min _ 1 min&#x2F;7200 rotations &#x3D; 8.33 ms<br>*rotation delay（求期望值取平均） &#x3D; 4.165 ms<br>*seek time: 10.5 ms (given)<br>_transfer time: 512 bytes _ 1 s&#x2F;54 MB * 1MB&#x2F;10^6 bytes &#x3D; .0095 ms</p>
<p>*asawhole–oneread &#x3D; 14.66ms<br>ans: rotation delay + seek time + transfer_time *500 &#x3D; 8.33 + 4.165 + 0.0095 * 500 &#x3D; 19.5 ms</p>
<p>throughput &#x3D; 500 * 512 B &#x2F; 19.5 ms &#x3D; 13.1 MB&#x2F;s</p>
<blockquote>
<p>–”The secret to making disks fast is to treat them like tape (John Ousterhout).</p>
</blockquote>
<h2 id="hw9"><a href="#hw9" class="headerlink" title="hw9"></a>hw9</h2><h3 id="1-mmap"><a href="#1-mmap" class="headerlink" title="1. mmap()"></a>1. mmap()</h3><p>Consider the following code excerpt that uses mmap():</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The signature of mmap is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   void* mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If addr is NULL, the kernel chooses the start virtual address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If not already in memory, disk blocks are fetched into physical pages on access.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Each separate call to mmap() with the same fd maps the file in a separate</span></span><br><span class="line"><span class="comment">// location and does not undo prior mappings. This means that in the example</span></span><br><span class="line"><span class="comment">// above, the file can be read and written from multiple virtual addresses</span></span><br><span class="line"><span class="comment">// within the same address space.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// readme.txt is a file that is 5KB in length.</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;readme.txt&quot;</span>, O_RDWR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *map1 = (<span class="type">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">5120</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *map2 = (<span class="type">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assume that neither mmap call fails</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Line 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5120</span>; i++) &#123;</span><br><span class="line">        x = map1[i];</span><br><span class="line">        y = map2[i % <span class="number">4096</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Line 2</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Assume the operating system minimizes the number of virtual and physical pages required in order to implement mmap().</p>
<ol>
<li><p>How many last-level (level-4) page table entries are created or modified as a result of the two mmap() calls?<br><strong>ans</strong>: 3.</p>
<ol>
<li>第一个map两个VP -&gt; PA1 &amp; PA2</li>
<li>第二个map用了一个VP -&gt; PA1.</li>
</ol>
</li>
<li><p>At line 2, how many physical pages are mapped into the process as a result of the mmap() calls?<br><strong>ans</strong>: 2个PA. 综上。</p>
</li>
</ol>
<h3 id="2-Context-switches"><a href="#2-Context-switches" class="headerlink" title="2. Context switches"></a>2. Context switches</h3><p>In this question, you will implement <strong>swtch</strong>(), which switches between two user-level threads. You will do so for a user-level threading package, running on the TeensyArch processor. TeensyArch has 4 general registers, %r0-%r3, a stack pointer, a base (or frame) pointer, and an instruction pointer %rip. Assume the same stack frame structure as the architecture we’ve been covering in class (x86); further, all registers need to be saved by a function’s callee (that is, registers are callee-saved, also known as call-preserved).</p>
<p>Fill out swtch(). Below are definitions, declarations, and utility functions that you can use.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> thread_id;</span><br><span class="line">    <span class="type">uint64_t</span> <span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">register</span> &#123;</span></span><br><span class="line">    R0,</span><br><span class="line">    R1,</span><br><span class="line">    R2,</span><br><span class="line">    R3,</span><br><span class="line">    RBP,</span><br><span class="line">    RSP</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push CPU&#x27;s register r to the stack</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_register</span><span class="params">(<span class="keyword">register</span> r)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop from the stack and into the CPU&#x27;s register r</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_register</span><span class="params">(<span class="keyword">register</span> r)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the CPU&#x27;s current value of register r.</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">read_register</span><span class="params">(<span class="keyword">register</span> r)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the CPU&#x27;s register r so it holds value `value`.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_register</span><span class="params">(<span class="keyword">register</span> r, <span class="type">uint64_t</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context switch from thread t1 to thread t2.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> thread *t1, <span class="keyword">struct</span> thread *t2)</span> &#123;</span><br><span class="line">    <span class="comment">// On entry this function is run by thread t1.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here. We have started it for you.</span></span><br><span class="line">    push_register(RBP);</span><br><span class="line">    push_register(R0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">    <span class="comment">// **ans**</span></span><br><span class="line">    push_register(R1);</span><br><span class="line">    push_register(R2);</span><br><span class="line">    push_register(R3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swtch rsp</span></span><br><span class="line">    <span class="comment">// 1. save to tcb 2. swtch to t2&#x27;s rsp</span></span><br><span class="line">    t1-&gt;<span class="built_in">stack</span> = read_register(RSP);</span><br><span class="line">    write_register(RSP, r2-&gt;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    pop_register(R3);</span><br><span class="line">    pop_register(R2);</span><br><span class="line">    pop_register(R1);</span><br><span class="line">    push_register(R0);</span><br><span class="line">    push_register(RBP);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// The function should return to the</span></span><br><span class="line">            <span class="comment">// point where thread t2 called swtch().</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Polling-vs-interrupts"><a href="#3-Polling-vs-interrupts" class="headerlink" title="3. Polling vs. interrupts"></a>3. Polling vs. interrupts</h3><p>As discussed in class, two ways for an operating system to become aware of external events associated with a device are <strong>interrupts</strong> and <strong>polling</strong>. We observed that if a computer were receiving many interrupts, it might spend all of its time processing them and not get other work done; in that case, the operating system should switch to polling the device. Now consider the following:</p>
<ul>
<li><p>A computer has an attached keyboard. The keyboard has a <strong>1024</strong>-byte internal memory buffer to hold the codes of recently-pressed keys, each of which consumes 2 bytes of buffer space. (The buffer is a FIFO, which for our purposes means that the OS simply reads from it and doesn’t manage the memory; if this parenthetical confuses you, you can ignore it.)</p>
</li>
<li><p>This computer and its OS take <strong>1 microsecond</strong> ($10^{−6}$ seconds) to handle an interrupt from the keyboard. That duration includes everything: reading from the keyboard’s buffer, determining which key was pressed, and painting the appropriate letter to the screen.</p>
</li>
<li><p>Assume that polling requires a fixed cost of <strong>1 microsecond per poll</strong>. Further assume that, per poll, the operating system can read an arbitrary amount of the keyboard’s internal memory buffer, up to the <strong>entire size of that buffer</strong>.</p>
</li>
<li><p>Assume that, if polling, the operating system checks the device in question every <strong>200 milliseconds</strong>.</p>
</li>
<li><p>Assume that humans are sensitive to lags of <strong>100 milliseconds or greater</strong>. Specifically, if a human types a letter, that letter must appear on the screen less than 100 milliseconds after the human types it, to avoid annoyance.</p>
</li>
<li><p>You type exceptionally quickly: 200 words per minute. Assume that the average word has 7 letters, including the space at the end of the word.</p>
</li>
</ul>
<p>Each key code (each letter, in other words) generates a separate interrupt.</p>
<ol>
<li><p>How many interrupts per second would your typing generate on average? Show your work.<br><strong>ans</strong>:<br># of interrupts &#x3D; 1400 &#x2F;60 &#x3D; <strong>23</strong></p>
</li>
<li><p>Should the computer use polling or interrupts to handle your fast typing? Explain why your choice is acceptable and the other choice is not. Do not use more than three sentences.<br><strong>ans</strong>: <strong>interrupt</strong>. 23us &lt;&lt; 200 ms</p>
</li>
</ol>
<h3 id="4-Disk-performance"><a href="#4-Disk-performance" class="headerlink" title="4. Disk performance"></a>4. Disk performance</h3><ul>
<li>The disk rotates at 12,000 RPM (rotations per minute)</li>
<li>The disk has 10 platters (and 10 corresponding heads); the cost to change which head is active is zero</li>
<li>Each sector is 512 bytes</li>
<li>There are 1024 sectors per track (we are ignoring the fact that the number of sectors per track varies on a real disk)</li>
<li>There are 4096 tracks per platter</li>
<li>The average seek time is 15 ms.</li>
<li>Ignore the time to transfer the bits from the disk to memory; that is, once the disk head is positioned over the sector, the transfer happens instantaneously.</li>
</ul>
<ol>
<li>What is the storage capacity of the disk in bytes or gigabytes? (Explain briefly.)<br><strong>ans</strong>:</li>
</ol>
<p>10 _ 4096 _ 1024 * 512 B &#x3D; 20GB</p>
<ol start="2">
<li>What is the sequential transfer bandwidth, expressed in bytes&#x2F;second or megabytes&#x2F;second? (Explain briefly.)<br><strong>ans</strong>:</li>
</ol>
<p>rotation time per rotation &#x3D; 60s &#x2F; 12000 rotations &#x3D; 1 &#x2F; 200 s</p>
<p>bandwidth &#x3D; 1024 * 512 B &#x2F; (1&#x2F; 200 s) &#x3D; 100 MB &#x2F; s</p>
<ol start="3">
<li>Now assume that the disk with the above characteristics is given a never-ending stream of requests to read one sector at a time, with each request chosen randomly from all possible <strong>sectors</strong> on the disk. Assume that these read requests are scheduled in FIFO order. State the effective long-term transfer rate that the disk can sustain, expressed in bytes&#x2F;second or kilobytes&#x2F;second, and explain briefly.<br><strong>ans</strong>:</li>
</ol>
<p>512 bytes &#x2F; 17.5 ms ≈ 525 &#x2F; 17.5 bytes&#x2F;ms &#x3D; 30,000 bytes&#x2F;second</p>
<p><strong>hint</strong>: In doing the third question, the following may be useful:</p>
<ul>
<li>You can (and probably should) make several percentage point approximations, for example 4096 can be represented as 4000, and 13 × 7.5 is approximately 100.</li>
<li>The term “long-term transfer rate” refers to R&#x2F;X, where R is the number of bytes to transfer in each read, and X is the average length of time that a read takes.</li>
</ul>
<h3 id="5-Disk-scheduling"><a href="#5-Disk-scheduling" class="headerlink" title="5. Disk scheduling"></a>5. Disk scheduling</h3><p>TODO</p>
<h2 id="Lecture-19-20-File-systems-I-II"><a href="#Lecture-19-20-File-systems-I-II" class="headerlink" title="Lecture 19&#x2F;20: File systems I&#x2F;II"></a>Lecture 19&#x2F;20: File systems I&#x2F;II</h2><p><em>File system, 启动！</em></p>
<h3 id="file-system的功能"><a href="#file-system的功能" class="headerlink" title="file system的功能:"></a>file system的功能:</h3><ol>
<li><strong>它的功能</strong>：</li>
</ol>
<ul>
<li><strong>provide persistence</strong>: data never goes away</li>
<li><strong>提供抽象</strong>：<ul>
<li>用户认为是一个存东西的name —fs–&gt; {disk blocks, sectors}</li>
<li><code>create(file)</code>,</li>
<li><code>delete(file)</code>,</li>
<li><code>read()</code>,</li>
<li><code>write()</code></li>
<li>一些相关的我们在system中见过的translation<img src="/2024/01/22/NYU_OS/image-47.png" class="" title="alt text">
标准：operations have as few disk accesses as possible and minimal space overhead</li>
</ul>
</li>
</ul>
<p>想象一个用户的使用场景：<br>(i) Sequential:<br>–File data processed in sequential order<br>–By far the most <strong>common</strong> mode<br>–Example: editor writes out new file, compiler reads in file, etc</p>
<p>(ii) Random access:<br>–Address any block in file directly without passing through the rest of the blocks<br>–Examples: large data set, demand paging, databases</p>
<p><strong>helpful observations</strong>:</p>
<ul>
<li>All blocks in file tend to be used together, sequentially</li>
<li>All files in directory tend to be used together</li>
<li>All <em>names</em> in directory tend to be used together</li>
<li>Most files are small</li>
<li>Much of the disk is allocated to large files</li>
<li>Many of the I&#x2F;O operations are made to large files</li>
<li>Want good sequential and good random access</li>
</ul>
<h3 id="Files-Implementations"><a href="#Files-Implementations" class="headerlink" title="Files Implementations:"></a>Files Implementations:</h3><ol>
<li>contiguous<br>–when creating a file, make user pre-specify its length, and allocate the space at once<br>–file metadata contains location and size</li>
</ol>
<p>最大的缺点:</p>
<ul>
<li>会有文件碎片，不好回收。</li>
</ul>
<ol start="2">
<li>linked files<br>–keep a linked list of free blocks<br>–metadata: pointer to file’s first block<br>–each block holds pointer to next one</li>
</ol>
<p>缺点：</p>
<ul>
<li>random access cost高。</li>
</ul>
<ol start="3">
<li>indexed files<br>–Each file has an array holding all of its block pointers like a page table, so similar issues crop up<img src="/2024/01/22/NYU_OS/image-67.png" class="" title="alt text">
优点很大: 方便维护，random access，可回收都很棒。</li>
</ol>
<p>缺点：</p>
<ul>
<li><p>大小不好控制。</p>
<p>3.1 优化成多层树。<br>缺点：</p>
</li>
<li><p>data access太烦了，每次都要像多级页表那样读四次。</p>
<img src="/2024/01/22/NYU_OS/image-66.png" class="" title="alt text">

<p>3.2 优化成一些direct, 一些indirect，最后一些double block。</p>
<blockquote>
<p>system is about compromise.</p>
<img src="/2024/01/22/NYU_OS/image-65.png" class="" title="alt text">
<p>Notes:</p>
</blockquote>
</li>
<li><p>metadata?</p>
<ul>
<li>inodes? 存在了fixed-sized array里面，这个具体看fs实现方式。</li>
</ul>
</li>
</ul>
<h3 id="Implementation-of-Directories"><a href="#Implementation-of-Directories" class="headerlink" title="Implementation of Directories"></a>Implementation of Directories</h3><p><strong>links</strong>:</p>
<ol>
<li><p>hard link: multiple dir entries point to same inode;</p>
</li>
<li><p>soft link: synonym for a <em>name</em><br><code>&quot;ln -s /d/a b&quot;</code>:</p>
<pre><code>--creates a new inode, not just a new directory entry

--new inode has &quot;sym link&quot; bit set

--contents of that new file:

    &quot;/d/a&quot;
</code></pre>
</li>
</ol>
<p><strong>Case Study – FFS</strong>:<br><a href="file-ffs.pdf">file-ffs.pdf</a></p>
<h2 id="HW-10-FS"><a href="#HW-10-FS" class="headerlink" title="HW 10 FS"></a>HW 10 FS</h2><h3 id="1-File-systems"><a href="#1-File-systems" class="headerlink" title="1. File systems"></a>1. File systems</h3><p>Consider a file system that has the following description:</p>
<ul>
<li><p>The disk is divided into <strong>1024</strong>-byte blocks.</p>
</li>
<li><p>The beginning of the disk contains an array of <strong>216</strong> inodes, each of which can represent a <strong>file</strong> or be unallocated.</p>
</li>
<li><p>A file has an <strong>indexed</strong> structure: an inode contains<br>(a) 8 data block pointers, each of which is 4 bytes and each of which points to a disk block and<br>(b) a pointer to ONE indirect block, which is a disk block that itself contains data block pointers.</p>
</li>
<li><p>The inode also contains a userid (2 bytes), three time stamps (4 bytes each), protection bits (2 bytes), a reference count (3 bytes), and the size (4 bytes).</p>
</li>
<li><p>A directory contains a list of (file_name, inode_number) pairs, where the file_name portion is always exactly 14 bytes, including the null terminator (if the file_name would otherwise be fewer than 14 bytes, it is padded to 14 bytes).</p>
<p>1.1 State the maximum file size, and explain briefly, for example by showing your work. You may express your answer as a sum of powers-of-two.<br><strong>ans</strong>: 1024B _ 8 + (1024 &#x2F; 4) _ 1024B &#x3D; 8KB + 256KB &#x3D; 264KB</p>
<p>1.2 State the maximum number of files in a directory, and explain briefly, for example by showing your work. Again, you may express your answer as a sum of powers-of-two.<br><strong>ans</strong>: 264KB &#x2F; 16 &#x3D; 16.5KB</p>
</li>
</ul>
<h3 id="2-File-systems"><a href="#2-File-systems" class="headerlink" title="2. File systems"></a>2. File systems</h3><p>Consider a UNIX-like file system with multi-level indexing. For more reliability, the inode array is replicated on the disk in two different places. The intent is that if one or a group of sectors that are storing either replica of the array becomes corrupted, the system can always recover from the other replica. Discuss the effect of having this replicated data structure on performance.</p>
<p><strong>ans</strong>: Every operation of the file system except Reed opeartion requries updating inode array twice on separate two directories.</p>
<h3 id="3-Zero-copy-I-O"><a href="#3-Zero-copy-I-O" class="headerlink" title="3. Zero-copy I&#x2F;O"></a>3. Zero-copy I&#x2F;O</h3><p>In some operating systems, IO from&#x2F;to disk is done directly to&#x2F;from a buffer in the user process’s memory. The user program does a system call specifying the address and length of the buffer (the length must be a multiple of the disk sector size). The disk controller needs a physical memory address, not a virtual address. Your friend proposes that when the user does a write system call, the operating system should check that the user’s virtual address is valid, translate it into a physical address, and pass that address and the length (also checked for validity) to the disk hardware.</p>
<p>q: This won’t quite work. In no more than two sentences, what did your friend forget?</p>
<p><strong>ans</strong>:<br>Contiguous VA does not map to contiguous PA. So a user sending a VA and a specified length may write to different PA.</p>
<h2 id="Lecture-21-Crash-recovery"><a href="#Lecture-21-Crash-recovery" class="headerlink" title="Lecture 21: Crash recovery"></a>Lecture 21: Crash recovery</h2><p>Solution: the system requires a notion of atomicity</p>
<ol>
<li>Ad hoc – 用一种fsck的unix 工具，在每次crash之后的重启都进行一遍consistency的检查。<ul>
<li>缺点<ul>
<li><strong>慢</strong>。遍历所有太慢了。</li>
<li><strong>浪费空间</strong>。会有垃圾文件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-copy-on-write"><a href="#2-copy-on-write" class="headerlink" title="2. copy on write"></a>2. copy on write</h3><p>在文件系统中，COW的使用比较花内存 – 就是系统花更多的空间先写入一份copy，直到最后的commit阶段（文件系统维护的Uberblock指向根目录的时候）才算结束。</p>
<img src="/2024/01/22/NYU_OS/image-68.png" class="" title="alt text">
<img src="/2024/01/22/NYU_OS/image-69.png" class="" title="alt text">
<img src="/2024/01/22/NYU_OS/image-70.png" class="" title="alt text">

<p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/copy-on-write.html">Copy-on-write技术在fork实现中的应用</a></p>
<h3 id="3-Journaling"><a href="#3-Journaling" class="headerlink" title="3. Journaling"></a>3. Journaling</h3><ul>
<li>Committed file system operations are reflected in on-disk data structures.</li>
<li>Uncommitted file system operations are not visible after crash recovery.</li>
</ul>
<p>Record enough information to finish applying committed operations (<em>redo operations</em>) and&#x2F;or roll-back uncommitted operations (<em>undo operations</em>).</p>
<h4 id="redo-logging"><a href="#redo-logging" class="headerlink" title="redo logging:"></a>redo logging:</h4><p>Step 1: fs事先计算好要有哪些数据结构的变化。</p>
<p>Step 2: fs在log里写入transaciton begin record (with an id).</p>
<p>Step 3: fs在log里写入准备变化的数据结构。</p>
<p>Step 4: fs在log里写入transaciton end record (with an id).</p>
<p>Step 5: Once the TxnEnd record has been written, the filesystem asynchronously performs the actual file system changes; this process is called <strong>checkpointing</strong>.</p>
<ul>
<li>Crash recovery: During crash recovery, the filesystem needs to read through the logs, determine the set of <strong>committed</strong> operations, and then apply them. Observe that:</li>
</ul>
<p>– The filesystem can determine whether a transaction is committed or not by comparing transaction IDs in TxnBegin and TxnEnd records.</p>
<p>– It is safe to apply the same redo log multiple times.</p>
<p>Operationally, when the system is recovering from a crash, the system does the following:</p>
<p>Step 1: The file system starts scanning from the beginning of the log.</p>
<p>Step 2: Every time it finds a TxnBegin entry, it searches for a corresponding TxnEnd entry.</p>
<p>Step 3: If matching TxnBegin and TxnEnd entries are found – indicating that the transaction is committed – the file system applies (checkpoints) the changes.</p>
<p>Step 4: Recovery is completed once the entire log is scanned.</p>
<p>Note, for redo logs, filesytems generally begin scanning the log from the <strong>start of the log</strong>.</p>
<h4 id="undo-logging"><a href="#undo-logging" class="headerlink" title="undo logging:"></a>undo logging:</h4><p>undo相较于redo logging的优势在于它可以只执行一次计算，如果顺利的话。</p>
<p>Step 1: fs在log里写入transaciton begin record (with an id).</p>
<p>Step 2: fs计算好要有哪些数据结构的变化，fs写入一条sub-operation之后，fs马上开始执行它。</p>
<p>Step 3: Wait for in-place changes (what we referred to as checkpointing) to finish for all blocks.</p>
<p>Step 4: Write a TxnEnd entry into the block, thereby committing the transaction.</p>
<p><em>Note</em>: 当commit阶段结束的时，在磁盘上的data structure就被顺利修改了.</p>
<ul>
<li>During crash recovery:</li>
</ul>
<p>Step 1: Scan the log to find all uncommitted transactions, these are ones where a TxnBegin entry is present, but no TxnEnd entry is found.</p>
<p>Step 2: For each such transaction check to see whether the undo entry is valid. This is usually done through the use of a checksum.</p>
<p>Why do we need this? Remember a crash might occur before the undo entry has been successfully written. If that happened, then (by the procedure described above), the actual changes corresponding to this undo entry have not been written to disk, so ignoring this entry is safe. On the other hand, trying to undo using a partially complete entry might result in data corruption, so using this entry would be <strong>unsafe</strong>.</p>
<p>Step 3: Apply all valid undo entries found, in order to restore the disk to a consistent state.</p>
<p>Note, for undo logs, logs are generally scanned from the <strong>end of the log</strong>.</p>
<ul>
<li><p>Advantage: Changes can be checkpointed to disk as soon as the undo log has been updated. This is beneficial when the amount of buffer cache is low.</p>
</li>
<li><p>Disadvantage: A transaction is not committed until all dirty blocks have been flushed to their in-place targets.</p>
</li>
</ul>
<h2 id="HW-11-File-systems-reliability"><a href="#HW-11-File-systems-reliability" class="headerlink" title="HW 11: File systems reliability"></a>HW 11: File systems reliability</h2><h3 id="1-File-systems-1"><a href="#1-File-systems-1" class="headerlink" title="1. File systems"></a>1. File systems</h3><p>Is it fundamentally necessary to store on disk information about the unallocated disk sectors (the bitmap, etc.)? Explain why or why not.</p>
<p><strong>ans</strong>: No, since we can traverse the disk by its block numbers. (extremely inefficient)</p>
<h3 id="2-File-systems-1"><a href="#2-File-systems-1" class="headerlink" title="2. File systems"></a>2. File systems</h3><p>Suppose you have a file system with: multi-level indexing (with 14 direct pointers, 1 indirect inode, 1 doubly indirect pointer, and 1 triple indirect pointer in the inode), directories, and inodes statically allocated in an array [0..MAX_INUM] in a known location on disk. Also assume there is an on-disk bitmap of free inodes and free blocks. Assume that the file containing the root directory is stored in a well-known inode with inumber ROOT_INUM.</p>
<p>Assume each inode consumes exactly one block.</p>
<p>Consider creating a new file “&#x2F;foo&#x2F;bar” in an existing directory “foo” and writing one block of data to that file.</p>
<p>Assume no in-memory cache.</p>
<ol>
<li>List the reads and writes that must be executed to accomplish this task (and explain how each disk address is determined.)<br><strong>ans</strong>:</li>
</ol>
<ul>
<li>R &#x2F; inode</li>
<li>R &#x2F;foo inode</li>
<li>R free inodes</li>
<li>W free inode not free</li>
<li>W &#x2F;foo inode</li>
<li>R free sectors</li>
<li>W &#x2F;foo&#x2F;bar inode</li>
<li>W data in sectors</li>
<li>W data block not free</li>
</ul>
<p>总的来说：关注以下的数据结构：</p>
<ul>
<li>inode blocks</li>
<li>data blocks</li>
</ul>
<p>以及以下对他们的操作：</p>
<ul>
<li>R &lt; which block&gt;</li>
<li>W (mark free or not)</li>
<li>W &lt; which block&gt; (写入数据或者是加入bookkeeping)</li>
</ul>
<ol start="2">
<li><p>Write down the writes in the order they should occur.<br><strong>ans</strong>: 1. W data to the data block 2. W inode to reference the data block 3. W mark the inode not free 4. W mark the data block not free 5. W inode of ‘&#x2F;foo’ (add &lt;bar,ino&gt; )</p>
</li>
<li><p>List the actions that the FSCK program must take to ensure the disk is brought to a correct state on recovery, and argue that these actions guarantee file system consistency.<br><strong>ans</strong>:</p>
<pre><code>1. examine all allocated inodes, check the pointers, if it points to a block marked as free in the free block bitmap, modify the bitmap.
2. examine the direcotory hierarchy, any unreachable and allocated inode will be freed.
</code></pre>
</li>
<li><p>Suppose we want to ensure reliable updates using logging (as in a journaling file system). List the series of writes (to the disk and log) in the order they should occur. Also describe what actions (if any) must be taken on recovery after a crash.<br><strong>ans</strong>:<br>Assume redo-only logging</p>
<pre><code>1  W (Log) BEGIN_TX
2  W (Log) log a write to data block, need to log blk# and data written to the blk
3  W (Log) log a write to an inode, need to log i-number and values written to this inode
4  W (Log) log a write to free inode bitmap (Not necessary)
5  W (Log) log a write to free disk blk bitmap (Not necessary)
6  W (Log) log a write to inode of ‘/foo’, need to log the blk# and content written to it
7  W (Log) END_TX
8  W data to the data block
9  W inode to add the data block
10 W mark the inode not free
11 W mark the data block not free
12 W inode of ‘/foo’ (add /foo/bar)

In terms of the ordering:
(1 || 2 || 3 || 4 || 5 || 6) &lt; 7 &lt; (8 || 9 || 10 || 11 || 12)

by which we mean:

1-6 can be done in any order, but all have to happen before 7.
8-12 can be done in any order, but all have to happen after 7.

4, 5 are not necessary since 2 and 3 have already logged enough
information for 4, 5.

For recovery:

The system should scan through all log entries. Starting from the
beginning of the log towards the end, the system should replay all
log entries for transactions that have an END_TX record with an id
that matches the BEGIN_TX record.
</code></pre>
</li>
</ol>
<h3 id="3-Crash-recovery-Copy-on-write"><a href="#3-Crash-recovery-Copy-on-write" class="headerlink" title="3. Crash recovery: Copy-on-write"></a>3. Crash recovery: Copy-on-write</h3><p>Consider a copy-on-write filesystem. Alice executes rm &#x2F;home&#x2F;alice&#x2F;lab.c, where lab.c has 2 data blocks. Assume all directory entries are in direct blocks. List the operations performed by the filesystem when deleting lab.c, and specify any ordering constraints that must be obeyed between operations. Additionally, state any assumptions you make about how directory inodes are stored.</p>
<p><strong>ans</strong>:</p>
<pre><code>Assume that directories store their entries inside the directory
inode. Further assume that the FS performs garbage collection in the
background (to recycle inodes and data blocks), so we don&#39;t have to
worry about bitmaps. Then the operations are:

- write a new directory inode for /home/alice that is a copy of the
  old one (call the old one D), except removing the entry &lt;lab.c,
  NUM&gt;, where NUM is the inode number. Call this new directory inode
  D&#39;.

- write a new directory inode for /home that is a copy of the old
  one, except &lt;alice,D&gt; is replaced with &lt;alice,D&#39;&gt;. call the new
  directory inode for /home E&#39; and the old one E.

- likewise for /: write a copy of the inode for / (call the old one
  F), replacing &lt;home,E&gt; with &lt;home,E&#39;&gt;.  Call the new inode F&#39;.

- *rewrite* (not copy) the uberblock to point to F&#39;, rather than F.
</code></pre>
<h4 id="4-Crash-recovery-Undo-redo-logging"><a href="#4-Crash-recovery-Undo-redo-logging" class="headerlink" title="4. Crash recovery: Undo-redo logging"></a>4. Crash recovery: Undo-redo logging</h4><p>Consider the redo-undo logging protocol from class. Why can’t we eliminate the undo pass, and just have a redo pass in which we redo only sub-operations from committed transactions?</p>
<p><strong>ans</strong>: The redo-undo logging protocol allows the file system to checkpoint (flush to the file system data structures) updates from <em>uncommitted</em> operations. If there were a crash during an uncommitted operation, which the file system had partially applied, then a recovery protocol without the undo pass would leave the file system in an inconsistent state (with the uncommitted operation partially applied).</p>
<h2 id="Lecture-22-NFS"><a href="#Lecture-22-NFS" class="headerlink" title="Lecture 22: NFS"></a>Lecture 22: NFS</h2><p><a target="_blank" rel="noopener" href="https://cs.nyu.edu/~mwalfish/classes/24sp/lectures/l22.txt">l22.txt</a><br><a target="_blank" rel="noopener" href="https://cs.nyu.edu/~mwalfish/classes/24sp/lectures/scribble22.pdf">scribble22</a></p>
<h2 id="Lecture-23-stack-smashing"><a href="#Lecture-23-stack-smashing" class="headerlink" title="Lecture 23: stack smashing"></a>Lecture 23: stack smashing</h2><p><strong>bug in server</strong>:</p>
<img src="/2024/01/22/NYU_OS/image-71.png" class="" title="alt text">
<p>这是服务器的代码，他会把默认的fs 0， 1，2指向的monitor改成network connection。</p>
<img src="/2024/01/22/NYU_OS/image-72.png" class="" title="alt text">
<p>bug：没有check n的value导致溢出攻击的可能性。</p>
<p>correction: <code>n &gt; sizeof(buf) ? sizeof(buf): n</code></p>
<p><strong>如何攻击？</strong> ans: shell code</p>
<p>在exploit.c中实现的功能是：把要注入的code写好并且把buffer注满ret addr。</p>
<img src="/2024/01/22/NYU_OS/image-75.png" class="" title="alt text">

<p>而在server的栈上表现出来就是这样，最后ret的时候因为会先init %rsp到原先%rbp的地方，然后ret出来的就是9080了。最后就会导致server端执行shell codes，让exploit user来操作server权限的shell。</p>
<img src="/2024/01/22/NYU_OS/image-76.png" class="" title="alt text">

<h2 id="Lecture-24-Reflection-on-trusting-trust"><a href="#Lecture-24-Reflection-on-trusting-trust" class="headerlink" title="Lecture 24: Reflection on trusting trust"></a>Lecture 24: Reflection on trusting trust</h2><p><a target="_blank" rel="noopener" href="https://cs.nyu.edu/~mwalfish/classes/24sp/lectures/scribble24.pdf">scribble24.pdf</a></p>
<h2 id="Lecture-25-UNIX"><a href="#Lecture-25-UNIX" class="headerlink" title="Lecture 25 UNIX"></a>Lecture 25 UNIX</h2><p><a target="_blank" rel="noopener" href="https://cs.nyu.edu/~mwalfish/classes/24sp/lectures/scribble25.pdf">scribble25.pdf</a></p>
<ul>
<li>– <em>real</em> is user who launched the program</li>
<li>– <em>effective</em> (if different from <em>real</em>) is owner&#x2F;group of executable, used in access checks<blockquote>
<p>for a program marked “setuid”, on exec() of binary, kernel sets<br>effective uid &#x3D; file uid. NOTE: kernel would (for<br>non-setuid) mark effective uid &#x3D; real uid.</p>
</blockquote>
</li>
</ul>
<p>–&#x2F;usr&#x2F;bin&#x2F;passwd: change a user’s passwd. User needs to be able to run this, but only root can modify the password file. (所以这个program需要setuid来提升自己的 <em>effective</em> uid到root来使得自己能够改变自己的password（也就是改变evt&#x2F;shadow这个文件）的时候有root的权限)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cs202-user@d1d26b015839:~/cs202-labs$ <span class="built_in">ls</span> -l `<span class="built_in">which</span> passwd`</span><br><span class="line">-rwsr-xr-x 1 root root 59976 Nov 24 12:05 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以看见passwd确实是root拥有的，并且set好了<code>s</code>位，s位保证了setuid可以正常运行，把当前user的effective uid改成这个binary的owner（这个例子里是<code>root</code>）。</p>
</blockquote>
<p>–&#x2F;bin&#x2F;su: change to new user ID if correct password is typed. （就是改变当前的user的权限）</p>
<h3 id="第一种attack：小偷小摸-之-lunch-break-attack"><a href="#第一种attack：小偷小摸-之-lunch-break-attack" class="headerlink" title="第一种attack：小偷小摸 之 lunch break attack"></a>第一种attack：小偷小摸 之 <code>lunch break attack</code></h3><p>Imagine you leave your terminal unattended, and some other user (“attacker”) sits down and types:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">cp</span> /bin/sh /tmp/break-acct</span><br><span class="line"><span class="comment"># 最关键的是这一步：4 sets the setuid bit --&gt; 这个直接让所有人都可以以cs202-user的effective userid来执行shell。</span></span><br><span class="line">% <span class="built_in">chmod</span> 4755 /tmp/break-acct</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<blockquote>
<p>the leading 4 sets the setuid bit.<br>the 755 means “rwxr-xr-x”</p>
</blockquote>
<p>所以，<br>Attacker later runs (from their own account):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /tmp/break-acct -p</span><br></pre></td></tr></table></figure>

<h3 id="例子：第二种attack：fd-table-attack"><a href="#例子：第二种attack：fd-table-attack" class="headerlink" title="例子：第二种attack：fd table attack"></a>例子：第二种attack：<code>fd table attack</code></h3><p>– Close fd 2 before exec()ing program<br>– now, setuid program opens a file, for example the password file…. (normally, would be fd&#x3D;3, but because fd 2 was closed, the file will be given fd 2).</p>
<p>– then, the program later encounters an error message<br>and does fprintf(stderr, “some error msg”).</p>
<p>–result: the error message goes into the password file!</p>
<p>–fix: for setuid programs, kernel will open dummy fds for 0,1,2 if not already open</p>
<p>–Set maximum file size to zero (if, say, setuid program changes a password and then rebuilds some password database), which means the setuid program is now running in an adverse environment</p>
<p>解释：这里的突破口是在于Unix如何管理自己的fd table的。</p>
<h3 id="例子：第三种attack：奇葩preserve程序"><a href="#例子：第三种attack：奇葩preserve程序" class="headerlink" title="例子：第三种attack：奇葩preserve程序"></a>例子：第三种attack：<code>奇葩preserve程序</code></h3><p>–”system” uses the shell to parse its argument</p>
<p>–now if IFS (internal field separator) is set to “&#x2F;“ before running vi, then we get the following:</p>
<p>IFS的作用是：set parse的时候用的delimiter</p>
<p>–vi forks and execs &#x2F;usr&#x2F;lib&#x2F;preserve (IFS is still set to ‘&#x2F;‘, but exec() call doesn’t care)</p>
<p>–preserve invokes system(“&#x2F;bin&#x2F;mail”), but this causes<br>shell to parse the arguments as: <code> bin mail</code></p>
<p>– 这个时候eviluser就可以写一个evil program叫<code>bin</code> <em>卧槽bin</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redefine IFS back to be tab, space, newline</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># then:</span></span><br><span class="line"><span class="built_in">cd</span> /homes/mydir/bin</span><br><span class="line"><span class="built_in">cp</span> /bin/sh ./sh</span><br><span class="line"><span class="built_in">chown</span> root sh  <span class="comment"># this succeeds because &#x27;bin&#x27; is running as root</span></span><br><span class="line"><span class="built_in">chmod</span> 4755 sh  <span class="comment"># this succeeds because &#x27;bin&#x27; is running as root</span></span><br></pre></td></tr></table></figure>

<p>解释：这里有俩错误：</p>
<ol>
<li>一个是preserve给到的setuid root的权限太夸张了。</li>
<li>第二个是preserve的实现中有IFS这个所有人都可以modify的东西。</li>
</ol>
<p>–fix:</p>
<ol>
<li>shell has to ignore IFS if the shell is running as root or if EUID !&#x3D; UID.</li>
<li>(also, “preserve” should not have been setuid root; there should have been a special user&#x2F;group just for this purpose.)</li>
</ol>
<p>Note: –also, modern shells refuse to run scripts that are setuid. (the issue there is a bit different, but it is related.)</p>
<h3 id="TOCTTOU-attacks-time-of-check-to-time-of-use"><a href="#TOCTTOU-attacks-time-of-check-to-time-of-use" class="headerlink" title="TOCTTOU attacks (time-of-check-to-time-of-use)"></a>TOCTTOU attacks (time-of-check-to-time-of-use)</h3><p>– say there’s a setuid program that needs to log events to a file, specified by the caller. The code might look like this, where logfile is from user input</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(logfile, O_CREAT|O_WRONLY|O_TRUNC, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>

<p>–what’s the problem?</p>
<p>ans：setuid program shouldn’t be able to write to file that user can’t. thus:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (access(logfile, W_OK) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">fd = open(logfile, ....)</span><br></pre></td></tr></table></figure>

<p>解释： attacker runs setuid program, passing it <code>/tmp/X</code></p>
<pre><code>    setuid program                          attacker
                            creat(&quot;/tmp/X&quot;);

  check access(&quot;/tmp/X&quot;) --&gt; OK

                            unlink(&quot;/tmp/X&quot;);
                            symlink(&quot;/etc/passwd&quot;, &quot;/tmp/X&quot;)

    open(&quot;/tmp/X&quot;)
</code></pre>
<h2 id="HW-12-NFS-security-and-review"><a href="#HW-12-NFS-security-and-review" class="headerlink" title="HW 12 NFS, security and review"></a>HW 12 NFS, security and review</h2><h3 id="1-Crash-recovery"><a href="#1-Crash-recovery" class="headerlink" title="1. Crash recovery"></a>1. Crash recovery</h3><p>Your friend wants to build a file system that tolerates crashes. Your friend proposes write-behind journaling. In this proposal, there is a journal, but the file system writes to the journal only after checkpointing (“checkpointing”, recall, means applying an operation to the on-disk data structures). Specifically, (1) the file system writes a TxnEnd record for a given transaction only after the TxnBegin record and all journal entries for the given transaction are written, and (2) the file system writes individual journal entries only after checkpointing the operation described by that entry. The recovery protocol looks for incomplete operations (those that are part of a transaction that lacks a TxnEnd record) and undoes those operations, similar to the way that recovery works for undo-only logging.</p>
<p>Assume that a crash can happen at any time. Does your friend’s proposal work? If so, argue that it is correct. If not, explain why not. Use no more than four sentences.</p>
<p><strong>ans</strong>：<br>This does not work. It violates the golden rule of atomicity (never modify the only copy). In more detail, there are certain operations that require writing to more than one place on the disk, for example, appending to a file (which might require writing to an indirect block, updating a bitmap, and updating the inode itself). If the machine crashes in between these different disk updates, then because the operation is not complete, the system never got to the point of writing a journal entry. Thus, the on-disk data structures are now inconsistent, and there is no indication in the logs. The recovery process as described does not detect or fix this issue.</p>
<h3 id="2-Buffer-overflow-vulnerabilities"><a href="#2-Buffer-overflow-vulnerabilities" class="headerlink" title="2. Buffer overflow vulnerabilities"></a>2. Buffer overflow vulnerabilities</h3><p>For the statements below, please state whether they are true or false. Justify each answer.</p>
<p>“If a server has a buffer overflow vulnerability, that means the server definitely has a bug.”<br>“Buffer overflow vulnerabilities can be ruled out by making the stack non-executable.”<br>“Buffer overflow vulnerabilities can be ruled out by making program text read-only.”<br>“Buffer overflow vulnerabilities can be ruled out with the W XOR X security policy.”<br>“Buffer overflow vulnerabilities can be eliminated with ASLR (address space layout randomization).”<br>“Buffer overflow vulnerabilities are not possible on a 64-bit architecture.”<br>“If a buffer overflow vulnerability is exploited, this implies that the attacker has changed %cr3.”</p>
<p><strong>ans</strong>：<br>2.1. True<br>2.2. False (counter-example: ROP)<br>2.3. False (counter-example: ROP)<br>2.4. False (counter-example: ROP)<br>2.5 False (counter-example: BROP attacks, discussed in class)<br>2.6. False (our demo platform is a 64-bit machine)<br>2.7. False</p>
<h2 id="Lab-5-File-system"><a href="#Lab-5-File-system" class="headerlink" title="Lab 5: File system"></a>Lab 5: File system</h2><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><ol>
<li>本project的构成：<img src="/2024/01/22/NYU_OS/image-7.png" class="" title="alt text"></li>
</ol>
<p>大白话解说：</p>
<p>首先我们先看左边，</p>
<img src="/2024/01/22/NYU_OS/image-8.png" class="" title="alt text">

<p>VFS在根据user process用的系统调用来决定用什么file system的接口，这个通常是再kernel中实现的file system。</p>
<p>但是为了让user也能做些事情，神奇的架构出现了，我们来看右边：</p>
<img src="/2024/01/22/NYU_OS/image-11.png" class="" title="alt text">

<p>FUSE (Filesystem in Userspace) 这个软件就是用来让user来实现filesystem然后传给VFS作为接口的。之后VFS在根据user process用的系统调用来决定用什么file system的接口。</p>
<blockquote>
<p>VFS asks the software below it to do things like “read”, “write”, etc.;</p>
</blockquote>
<p>因此，整体我们要做的的事情是：写一个新的file system到FUSE KERNEL MODULE – 这些file system 会使用disk driver的接口。</p>
<blockquote>
<p>Meanwhile, a FUSE driver can use whatever implementation it wants. It could store its data in memory, across the network, on Jupiter, whatever. In the setup in this lab, the FUSE driver will interact with a traditional Linux file (as noted above), and pretend that this file is a sector-addressable disk</p>
</blockquote>
<ol start="2">
<li>我们的file system提供什么功能？</li>
</ol>
<p>inode regions and data regions.</p>
<ul>
<li>Directory entries的data是：array of file names and inode numbers;</li>
<li>inode block和data block是一起的。</li>
</ul>
<img src="/2024/01/22/NYU_OS/image-18.png" class="" title="alt text">

<ul>
<li><p>一些杂的数据：block size &#x3D; 4KB； 每个inode一个disk block</p>
</li>
<li><p>Superblock：包含（block size, disk size, meta-data required to find the root directory, the time the file system was last mounted, the time the file system was last checked for errors, and so on）– 有关filesystem自身的数据都会存在这里。 — 我们存在block 0。逻辑是：<code>superblock.s_root.reftoblock</code>就是指向的root block。</p>
</li>
<li><p>管理disk内存使用：bitmap – one block for bitmap: 4KB -&gt; 32768 bits -&gt; represents 32768 blocks的使用。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">	<span class="type">uid_t</span>		i_owner; <span class="comment">// Owner of inode.</span></span><br><span class="line">	<span class="type">gid_t</span>		i_group; <span class="comment">// Group membership of inode.</span></span><br><span class="line">	<span class="type">mode_t</span>		i_mode; <span class="comment">// Permissions and type of inode.</span></span><br><span class="line">	<span class="type">dev_t</span>		i_rdev; <span class="comment">// Device represented by inode, if any.</span></span><br><span class="line">	<span class="type">uint16_t</span>	i_nlink; <span class="comment">// The number of hard links / number of references to the inode</span></span><br><span class="line">	<span class="type">int64_t</span>		i_atime; <span class="comment">// Access time (reads).</span></span><br><span class="line">	<span class="type">int64_t</span>		i_ctime; <span class="comment">// Change time (chmod, chown).</span></span><br><span class="line">	<span class="type">int64_t</span>		i_mtime; <span class="comment">// Modification time (writes).</span></span><br><span class="line">	<span class="type">uint32_t</span>	i_size; <span class="comment">// The size of the inode in bytes.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block pointers.</span></span><br><span class="line">	<span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">	<span class="type">uint32_t</span>	i_direct[N_DIRECT]; <span class="comment">// Direct blocks. reference to the blocks.</span></span><br><span class="line">	<span class="type">uint32_t</span>	i_indirect; <span class="comment">// Indirect block.</span></span><br><span class="line">	<span class="type">uint32_t</span>	i_double; <span class="comment">// Double-indirect block.</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>有关inode的维护：</p>
<ul>
<li><p>小文件可以直接读：10*4096 &#x3D; 40KB in size，<code>uint32_t i_direct[N_DIRECT];</code>通过<br>reference到10个block number，直接读。</p>
</li>
<li><p>大文件则需要<code>uint32_t i_indirect;</code>来指向一个充满了4096&#x2F;4 &#x3D; 1024 additional bloc<br>numbers的block来索引。我们的maximum file size可以到达(10 + 1024)*4096 &#x3D; 4136KB, or<br>little over 4MB.</p>
</li>
<li><p>更大的文件如下：</p>
<blockquote>
<p>A double-indirect block (i_double in the inode structure) stores 4096&#x2F;4 &#x3D; 1024 additional indirect block numbers, which themselves each store 1024 additional direct block numbers. This affords an additional 1024<em>1024</em>4096 &#x3D; 4GB worth of data, bringing the maximum file size to a little over 4GB, in theory.</p>
</blockquote>
</li>
</ul>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p>E1&#x2F;2: 读源码 + bookkeeping。</p>
<p>bitmap的构成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> bits[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// back up bitmap</span></span><br><span class="line">memmove(bits, bitmap, <span class="number">4096</span>);</span><br><span class="line"><span class="comment">// allocate block</span></span><br><span class="line"><span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;alloc_block: %s&quot;</span>, strerror(-r));</span><br><span class="line"><span class="comment">// check that block was free</span></span><br><span class="line">assert(bits[r/<span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (r%<span class="number">32</span>)));</span><br><span class="line"><span class="comment">// and is not free any more</span></span><br><span class="line">assert(!(bitmap[r/<span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (r%<span class="number">32</span>))));</span><br><span class="line">free_block(r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;alloc_block is good\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从<code>fs_test</code>中可知 — bitmap是和bit类似的结构。uint32_t的array；access的范式也可以从中得以一窥 – check block_no的状态<code>bitmap[block_no / 32] &amp; (1 &lt;&lt; (block_no % 32))</code>。</p>
<p>我打算还是先读懂dir.c和inode.c的所有代码之后再写。</p>
<p>我们先来分析inode.c中的一段遍历代码 – flush的作用主要是把调用一个flush_block函数，这个函数会把传给他的addr给刷新到disk中。我们要做的就是把</p>
<ol>
<li>inode本身和metadata block刷新到disk中。</li>
<li>把direct, indirect, double中referred的那些data block给刷新到disk中。</li>
</ol>
<p>同时我们可以理解inode_block_walk的作用，也就是索引的作用。<br>先在direct 里面找，之后indirect，之后。。。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">inode_flush</span><span class="params">(<span class="keyword">struct</span> inode *ino)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">uint32_t</span> *pdiskbno;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (ino-&gt;i_size + BLKSIZE - <span class="number">1</span>) / BLKSIZE; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inode_block_walk(ino, i, &amp;pdiskbno, <span class="number">0</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">		    pdiskbno == <span class="literal">NULL</span> || *pdiskbno == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		flush_block(diskblock2memaddr(*pdiskbno));</span><br><span class="line">	&#125;</span><br><span class="line">	flush_block(ino);</span><br><span class="line">	<span class="keyword">if</span> (ino-&gt;i_indirect)</span><br><span class="line">		flush_block(diskblock2memaddr(ino-&gt;i_indirect));</span><br><span class="line">	<span class="keyword">if</span> (ino-&gt;i_double) &#123;</span><br><span class="line">		<span class="comment">// We have to flush every indirect block allocated in</span></span><br><span class="line">		<span class="comment">// addition to the double-indirect block itself.</span></span><br><span class="line">		pdiskbno = diskblock2memaddr(ino-&gt;i_double);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N_INDIRECT; ++i)</span><br><span class="line">			<span class="keyword">if</span> (pdiskbno[i])</span><br><span class="line">				flush_block(diskblock2memaddr(pdiskbno[i]));</span><br><span class="line">		flush_block(diskblock2memaddr(ino-&gt;i_double));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec3:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the disk block number slot for the &#x27;filebno&#x27;th block in inode &#x27;ino&#x27;.</span></span><br><span class="line"><span class="comment">// Set &#x27;*ppdiskbno&#x27; to point to that slot.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The slot will be one of the</span></span><br><span class="line"><span class="comment">// 1. ino-&gt;i_direct[] entries ||</span></span><br><span class="line"><span class="comment">// 2. an entry in the indirect block ||</span></span><br><span class="line"><span class="comment">// 3. an entry in one of the indirect blocks referenced by the double-indirect block.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// option: When &#x27;alloc&#x27; is set, this function will allocate an indirect block or</span></span><br><span class="line"><span class="comment">// a double-indirect block (and any indirect blocks in the double-indirect</span></span><br><span class="line"><span class="comment">// block) if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//	0 on success (but note that **ppdiskbno might equal 0).</span></span><br><span class="line"><span class="comment">//	-ENOENT if the function needed to allocate an indirect block, but alloc was 0.</span></span><br><span class="line"><span class="comment">//	-ENOSPC if there&#x27;s no space on the disk for an indirect block.</span></span><br><span class="line"><span class="comment">//	-EINVAL if filebno is out of range (it&#x27;s &gt;= N_DIRECT + N_INDIRECT + N_DOUBLE).</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//  - You may find it helpful to draw pictures.</span></span><br><span class="line"><span class="comment">//  - Don&#x27;t forget to clear any block you allocate.</span></span><br><span class="line"><span class="comment">//  - Recall that diskblock2memaddr() converts from a disk block to an in-memory address</span></span><br><span class="line"><span class="comment">//  - You may end up writing code with a similar structure three times.</span></span><br><span class="line"><span class="comment">//  It may simplify your life to factor it into a helper function.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">inode_block_walk</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="type">uint32_t</span> filebno, <span class="type">uint32_t</span> **ppdiskbno, <span class="type">bool</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Error 1. allocate an indirect block, but alloc was 0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Error 2. no space</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Error 3.  out of range</span></span><br><span class="line">	<span class="keyword">if</span> (filebno &gt;= N_DIRECT + N_INDIRECT + N_DOUBLE) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// i_bno is absolute index in the file; i_filebno is abstract index</span></span><br><span class="line">	<span class="type">int</span> i_bno, i_filebno;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// search in direct block, simplest case -- return directly</span></span><br><span class="line">	<span class="keyword">if</span> (filebno &lt; N_DIRECT) &#123;</span><br><span class="line">		*ppdiskbno = &amp;ino-&gt;i_direct[filebno];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// search in indirect block.</span></span><br><span class="line">	filebno -= N_DIRECT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filebno &lt; N_INDIRECT) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// panic(&quot;inode_block_walk not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dir_lookup</code>很好的解释了dir的运作原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to find a file named &quot;name&quot; in dir.  If so, set *ino to it and</span></span><br><span class="line"><span class="comment">// set *dent to the directory entry associated with the file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 and sets *ino, *dent on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-ENOENT if the file is not found</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dir_lookup</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> dirent **dent, <span class="keyword">struct</span> inode **ino)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> i, j, nblock;</span><br><span class="line">	<span class="type">char</span> *blk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">d</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search dir for name.</span></span><br><span class="line">	<span class="comment">// We maintain the invariant that the size of a directory-file</span></span><br><span class="line">	<span class="comment">// is always a multiple of the file system&#x27;s block size.</span></span><br><span class="line">	assert((dir-&gt;i_size % BLKSIZE) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// i_size is how many data this inode refer to</span></span><br><span class="line">    <span class="comment">// 1. calculate number of blocks it refers to</span></span><br><span class="line">	nblock = dir-&gt;i_size / BLKSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">        <span class="comment">// 2. user algorithm to find the blk (the address of the blk)</span></span><br><span class="line">        <span class="comment">// set error if encountered error</span></span><br><span class="line">		<span class="keyword">if</span> ((r = inode_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">        <span class="comment">// 3. find the blk and cast the blk as direct array</span></span><br><span class="line">		d = (<span class="keyword">struct</span> dirent*) blk;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BLKDIRENTS; j++)</span><br><span class="line">            <span class="comment">// if we find the name in directory struct inode</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(d[j].d_name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// find the address of inum and pass the addr to ino</span></span><br><span class="line">				*ino = diskblock2memaddr(d[j].d_inum);</span><br><span class="line">                <span class="comment">// pass the actual addr into dent</span></span><br><span class="line">				*dent = &amp;d[j];</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码是差不多的</span></span><br><span class="line"><span class="comment">// 目的是：找到空的dirent并且返回，所以我们可以发现只有一小段核心代码是不一样的。</span></span><br><span class="line"><span class="comment">// 如果在所有dir的data block里面都没找到有空的，那么只能搞个新的了。</span></span><br><span class="line"><span class="comment">// Set *dent to point to a newly-allocated dirent structure in dir.  The</span></span><br><span class="line"><span class="comment">// caller is responsible for filling in the dirent fields.</span></span><br><span class="line"><span class="comment">// Returns 0 and sets *dent on success, &lt; 0 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dir_alloc_dirent</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dirent **dent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> nblock, i, j;</span><br><span class="line">	<span class="type">char</span> *blk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">d</span>;</span></span><br><span class="line"></span><br><span class="line">	assert((dir-&gt;i_size % BLKSIZE) == <span class="number">0</span>);</span><br><span class="line">	nblock = dir-&gt;i_size / BLKSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = inode_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		d = (<span class="keyword">struct</span> dirent*) blk;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BLKDIRENTS; j++)</span><br><span class="line">			<span class="keyword">if</span> (d[j].d_name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">				*dent = &amp;d[j];</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dir-&gt;i_size += BLKSIZE;</span><br><span class="line">	<span class="keyword">if</span> ((r = inode_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	d = (<span class="keyword">struct</span> dirent*) blk;</span><br><span class="line">	*dent = &amp;d[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是用的非常多的俩map方程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maps a block number to an address.  The pointer returned</span></span><br><span class="line"><span class="comment">// points to the first byte of the specified block in mapped memory.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">diskblock2memaddr</span><span class="params">(<span class="type">uint32_t</span> blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (blockno == <span class="number">0</span> || (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks))</span><br><span class="line">		panic(<span class="string">&quot;bad block number %08x in diskblock2memaddr&quot;</span>, blockno);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">char</span> *)(diskmap + blockno * BLKSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules the disk block associated with the given address to be</span></span><br><span class="line"><span class="comment">// flushed to disk.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">flush_block</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	addr = (<span class="type">void</span> *)((<span class="type">intptr_t</span>)addr &amp; ~(BLKSIZE - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span> (msync(addr, BLKSIZE, MS_ASYNC) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;msync(%p): %s&quot;</span>, addr, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Evaluate a path name, starting at the root.  On success,</span></span><br><span class="line"><span class="comment">// set *pino to the **inode** we found</span></span><br><span class="line"><span class="comment">// set *pdir to the **directory** the file is in</span></span><br><span class="line"><span class="comment">// set *pdent to the **directory entry** in pdir associated with the file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If we cannot find the file but find the directory it should be in,</span></span><br><span class="line"><span class="comment">// set *pdir and copy the final path element into lastelem.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 and sets non-NULL parameters on success, &lt; 0 on failure.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">walk_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> inode **pdir, <span class="keyword">struct</span> inode **pino, <span class="keyword">struct</span> dirent **pdent, <span class="type">char</span> *lastelem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// tmp variables that makes it convient to track</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">char</span> name[NAME_MAX];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>, *<span class="title">ino</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= PATH_MAX)</span><br><span class="line">		<span class="keyword">return</span> -ENAMETOOLONG;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if (*path != &#x27;/&#x27;)</span></span><br><span class="line">	<span class="comment">//	return -E_BAD_PATH;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// avoid the repetitive slashes</span></span><br><span class="line">	path = skip_slash(path);</span><br><span class="line">    <span class="comment">// start from the root inode (this is inode number -&gt; actual inode addr)</span></span><br><span class="line">	ino = diskblock2memaddr(super-&gt;s_root);</span><br><span class="line">	dir = <span class="number">0</span>;</span><br><span class="line">	dent = <span class="number">0</span>;</span><br><span class="line">	name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir)</span><br><span class="line">		*pdir = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pino)</span><br><span class="line">		*pino = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pdent)</span><br><span class="line">		*pdent = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		dir = ino;</span><br><span class="line">		p = path;</span><br><span class="line">		<span class="keyword">while</span> (*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">			path++;</span><br><span class="line">		<span class="keyword">if</span> (path - p &gt;= NAME_MAX)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		memmove(name, p, path - p);</span><br><span class="line">		name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		path = skip_slash(path);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!S_ISDIR(dir-&gt;i_mode))</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;dent, &amp;ino)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r == -ENOENT &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pdir)</span><br><span class="line">					*pdir = dir;</span><br><span class="line">				<span class="keyword">if</span> (lastelem)</span><br><span class="line">					<span class="built_in">strcpy</span>(lastelem, name);</span><br><span class="line">				<span class="keyword">if</span> (pino)</span><br><span class="line">					*pino = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (pdent)</span><br><span class="line">					*pdent = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir)</span><br><span class="line">		*pdir = dir;</span><br><span class="line">	<span class="keyword">if</span> (pino)</span><br><span class="line">		*pino = ino;</span><br><span class="line">	<span class="keyword">if</span> (pdent)</span><br><span class="line">		*pdent = dent;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一些爆典的在lab2就用过的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return information about the specified inode.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">inode_stat</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> stat *stbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pdiskbno 指的是pointer to disk block number.</span></span><br><span class="line">	<span class="type">uint32_t</span> i, nblocks, *pdiskbno;</span><br><span class="line"></span><br><span class="line">	stbuf-&gt;st_mode = ino-&gt;i_mode;</span><br><span class="line">	stbuf-&gt;st_size = ino-&gt;i_size;</span><br><span class="line">	stbuf-&gt;st_blksize = BLKSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们来看看这一段在写什么？</span></span><br><span class="line">    <span class="comment">// 首先roundup取了data block，之后遍历。</span></span><br><span class="line">    <span class="comment">// 之后对inode data block中的ith block进行一个walk，ptr指向的是那个block。</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, nblocks = <span class="number">0</span>; i &lt; ROUNDUP(ino-&gt;i_size, BLKSIZE) / BLKSIZE; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inode_block_walk(ino, i, &amp;pdiskbno, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (*pdiskbno != <span class="number">0</span>)</span><br><span class="line">			nblocks++;</span><br><span class="line">	&#125;</span><br><span class="line">	stbuf-&gt;st_blocks = nblocks * (BLKSIZE / <span class="number">512</span>); <span class="comment">// st_blocks unit is 512B.</span></span><br><span class="line">	stbuf-&gt;st_nlink = ino-&gt;i_nlink;</span><br><span class="line">	stbuf-&gt;st_mtime = ino-&gt;i_mtime;</span><br><span class="line">	stbuf-&gt;st_atime = ino-&gt;i_atime;</span><br><span class="line">	stbuf-&gt;st_ctime = ino-&gt;i_ctime;</span><br><span class="line">	stbuf-&gt;st_uid = ino-&gt;i_owner;</span><br><span class="line">	stbuf-&gt;st_gid = ino-&gt;i_group;</span><br><span class="line">	stbuf-&gt;st_rdev = ino-&gt;i_rdev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/links/">Links</a></li>
        
          <li><a href="/academic">Academic Page</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-1"><span class="toc-number">1.</span> <span class="toc-text">Lecture 1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0OS"><span class="toc-number">1.1.</span> <span class="toc-text">为什么学习OS?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-2-3-Review-of-assembly"><span class="toc-number">2.</span> <span class="toc-text">Lecture 2&#x2F;3 Review of assembly</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x86-64-assembly"><span class="toc-number">2.1.</span> <span class="toc-text">x86-64 assembly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#design-of-assembly"><span class="toc-number">2.2.</span> <span class="toc-text">design of assembly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#syscall"><span class="toc-number">2.3.</span> <span class="toc-text">syscall</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-4-Shell-I"><span class="toc-number">3.</span> <span class="toc-text">Lecture 4: Shell I</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">3.1.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execve"><span class="toc-number">3.2.</span> <span class="toc-text">execve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-%E2%80%93-%E4%BB%8EOS%E7%9A%84%E8%A7%92%E5%BA%A6"><span class="toc-number">3.3.</span> <span class="toc-text">Process – 从OS的角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-%E2%80%93-%E4%BB%8EOS%E7%9A%84%E8%A7%92%E5%BA%A6"><span class="toc-number">3.4.</span> <span class="toc-text">thread – 从OS的角度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-1-2"><span class="toc-number">4.</span> <span class="toc-text">HW 1&#x2F;2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-Lab2-ls"><span class="toc-number">5.</span> <span class="toc-text">Lab1&#x2F; Lab2 ls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Argument-parsing"><span class="toc-number">5.1.</span> <span class="toc-text">Argument parsing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-Directories-file-systems-api"><span class="toc-number">5.2.</span> <span class="toc-text">Read Directories&#x2F; file systems api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation"><span class="toc-number">5.3.</span> <span class="toc-text">Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Testing-framework"><span class="toc-number">5.3.1.</span> <span class="toc-text">Testing framework</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-5-6-7-8-Concurrency-I-II-III-IV"><span class="toc-number">6.</span> <span class="toc-text">Lecture 5&#x2F;6&#x2F;7&#x2F;8: Concurrency I&#x2F;II&#x2F;III&#x2F;IV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8E%AA%E6%96%BD%EF%BC%9Alock"><span class="toc-number">6.1.</span> <span class="toc-text">第一个措施：lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%8E%AA%E6%96%BD%EF%BC%9Acv"><span class="toc-number">6.2.</span> <span class="toc-text">第二个措施：cv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combined-primitive-monitor"><span class="toc-number">6.3.</span> <span class="toc-text">Combined primitive: monitor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%83%E4%B9%A0%E3%80%82"><span class="toc-number">6.4.</span> <span class="toc-text">一些练习。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-of-lock"><span class="toc-number">6.5.</span> <span class="toc-text">Implementation of lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spin-lock"><span class="toc-number">6.6.</span> <span class="toc-text">spin lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spinlock-%E2%80%93-Lecture-stuff"><span class="toc-number">6.7.</span> <span class="toc-text">spinlock – Lecture stuff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spinlock-based-mutex"><span class="toc-number">6.8.</span> <span class="toc-text">Spinlock-based mutex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-3-4-5"><span class="toc-number">7.</span> <span class="toc-text">HW 3&#x2F;4&#x2F;5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-The-uses-of-threading"><span class="toc-number">7.1.</span> <span class="toc-text">1. The uses of threading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-practice"><span class="toc-number">7.2.</span> <span class="toc-text">2. practice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Time-of-check-to-time-of-use-TOCTTOU-bugs"><span class="toc-number">7.3.</span> <span class="toc-text">3. Time-of-check-to-time-of-use (TOCTTOU) bugs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Deadlock"><span class="toc-number">7.4.</span> <span class="toc-text">4. Deadlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Priority-Inversion"><span class="toc-number">7.5.</span> <span class="toc-text">5. Priority Inversion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Reader-Writer-Spinlock-Challenge"><span class="toc-number">7.6.</span> <span class="toc-text">6. Reader Writer Spinlock (Challenge)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84c-bug"><span class="toc-number">7.7.</span> <span class="toc-text">一个典型的c bug</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-9-Therac-25"><span class="toc-number">8.</span> <span class="toc-text">Lecture 9 Therac 25</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-10-Scheduler"><span class="toc-number">9.</span> <span class="toc-text">Lecture 10 Scheduler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-11-12-13-15-Virtual-Memory-I-II-III-IV"><span class="toc-number">10.</span> <span class="toc-text">Lecture 11&#x2F;12&#x2F;13&#x2F;15 Virtual Memory I&#x2F;II&#x2F;III&#x2F;IV&#x2F;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84-kernel%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">页表是怎么工作的 &lt;&#x3D;&#x3D;&gt; kernel中的代码逻辑是什么样的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hw-6-7-8"><span class="toc-number">11.</span> <span class="toc-text">hw 6&#x2F;7&#x2F;8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-16-I-O-in-general"><span class="toc-number">12.</span> <span class="toc-text">Lecture 16 I&#x2F;O in general</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-17-Context-Switch"><span class="toc-number">13.</span> <span class="toc-text">Lecture 17: Context Switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-18-Disks"><span class="toc-number">14.</span> <span class="toc-text">Lecture 18: Disks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Performance-%E8%AE%A1%E7%AE%97%EF%BC%9A"><span class="toc-number">14.1.</span> <span class="toc-text">Performance 计算：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hw9"><span class="toc-number">15.</span> <span class="toc-text">hw9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-mmap"><span class="toc-number">15.1.</span> <span class="toc-text">1. mmap()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Context-switches"><span class="toc-number">15.2.</span> <span class="toc-text">2. Context switches</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Polling-vs-interrupts"><span class="toc-number">15.3.</span> <span class="toc-text">3. Polling vs. interrupts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Disk-performance"><span class="toc-number">15.4.</span> <span class="toc-text">4. Disk performance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Disk-scheduling"><span class="toc-number">15.5.</span> <span class="toc-text">5. Disk scheduling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-19-20-File-systems-I-II"><span class="toc-number">16.</span> <span class="toc-text">Lecture 19&#x2F;20: File systems I&#x2F;II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file-system%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">16.1.</span> <span class="toc-text">file system的功能:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Files-Implementations"><span class="toc-number">16.2.</span> <span class="toc-text">Files Implementations:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-of-Directories"><span class="toc-number">16.3.</span> <span class="toc-text">Implementation of Directories</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-10-FS"><span class="toc-number">17.</span> <span class="toc-text">HW 10 FS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-File-systems"><span class="toc-number">17.1.</span> <span class="toc-text">1. File systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-File-systems"><span class="toc-number">17.2.</span> <span class="toc-text">2. File systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Zero-copy-I-O"><span class="toc-number">17.3.</span> <span class="toc-text">3. Zero-copy I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-21-Crash-recovery"><span class="toc-number">18.</span> <span class="toc-text">Lecture 21: Crash recovery</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-copy-on-write"><span class="toc-number">18.1.</span> <span class="toc-text">2. copy on write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Journaling"><span class="toc-number">18.2.</span> <span class="toc-text">3. Journaling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-logging"><span class="toc-number">18.2.1.</span> <span class="toc-text">redo logging:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-logging"><span class="toc-number">18.2.2.</span> <span class="toc-text">undo logging:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-11-File-systems-reliability"><span class="toc-number">19.</span> <span class="toc-text">HW 11: File systems reliability</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-File-systems-1"><span class="toc-number">19.1.</span> <span class="toc-text">1. File systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-File-systems-1"><span class="toc-number">19.2.</span> <span class="toc-text">2. File systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Crash-recovery-Copy-on-write"><span class="toc-number">19.3.</span> <span class="toc-text">3. Crash recovery: Copy-on-write</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Crash-recovery-Undo-redo-logging"><span class="toc-number">19.3.1.</span> <span class="toc-text">4. Crash recovery: Undo-redo logging</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-22-NFS"><span class="toc-number">20.</span> <span class="toc-text">Lecture 22: NFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-23-stack-smashing"><span class="toc-number">21.</span> <span class="toc-text">Lecture 23: stack smashing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-24-Reflection-on-trusting-trust"><span class="toc-number">22.</span> <span class="toc-text">Lecture 24: Reflection on trusting trust</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-25-UNIX"><span class="toc-number">23.</span> <span class="toc-text">Lecture 25 UNIX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8Dattack%EF%BC%9A%E5%B0%8F%E5%81%B7%E5%B0%8F%E6%91%B8-%E4%B9%8B-lunch-break-attack"><span class="toc-number">23.1.</span> <span class="toc-text">第一种attack：小偷小摸 之 lunch break attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%A7%8Dattack%EF%BC%9Afd-table-attack"><span class="toc-number">23.2.</span> <span class="toc-text">例子：第二种attack：fd table attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%A7%8Dattack%EF%BC%9A%E5%A5%87%E8%91%A9preserve%E7%A8%8B%E5%BA%8F"><span class="toc-number">23.3.</span> <span class="toc-text">例子：第三种attack：奇葩preserve程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TOCTTOU-attacks-time-of-check-to-time-of-use"><span class="toc-number">23.4.</span> <span class="toc-text">TOCTTOU attacks (time-of-check-to-time-of-use)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW-12-NFS-security-and-review"><span class="toc-number">24.</span> <span class="toc-text">HW 12 NFS, security and review</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Crash-recovery"><span class="toc-number">24.1.</span> <span class="toc-text">1. Crash recovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Buffer-overflow-vulnerabilities"><span class="toc-number">24.2.</span> <span class="toc-text">2. Buffer overflow vulnerabilities</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab-5-File-system"><span class="toc-number">25.</span> <span class="toc-text">Lab 5: File system</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">25.1.</span> <span class="toc-text">前置知识：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercise"><span class="toc-number">25.2.</span> <span class="toc-text">Exercise</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://flappy.name/2024/01/22/NYU_OS/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://flappy.name/2024/01/22/NYU_OS/&text=NYU OS log"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://flappy.name/2024/01/22/NYU_OS/&is_video=false&description=NYU OS log"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=NYU OS log&body=Check out this article: https://flappy.name/2024/01/22/NYU_OS/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://flappy.name/2024/01/22/NYU_OS/&title=NYU OS log"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://flappy.name/2024/01/22/NYU_OS/&name=NYU OS log&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://flappy.name/2024/01/22/NYU_OS/&t=NYU OS log"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024-2025
    Shengtao Yao
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/links/">Links</a></li><!--
     --><!--
       --><li><a href="/academic">Academic Page</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
